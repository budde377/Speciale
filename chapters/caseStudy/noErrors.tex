\section{Maps and lists}
This study concerns a constructed case to illustrate how the analysis work with the two array-types, lists and maps. What the program does is define an array of month names and use a loop to create an array with these month names as keys and the corresponding month number as value as seen in program \ref{lst:monthsNoError}. The first array is considered a list by the analysis whereas the second array is considered a map from strings to numbers. The last two lines of the program uses the map to look up the number of a month name provided by the user (from the superglobal \texttt{\$\_GET}). Since the definition of lists in the analysis does not take indices into account the analysis lose precision for the map in this example. The analysis can only tell it is a map from strings to unsigned integers and nothing more precise.

\begin{graph}
\centering
\captionsetup{justification=centering}
\begin{adjustbox}{max size={.3\textwidth}{.40\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};  
    \node [subtree, below of=en] (e1) {$\subt{T_1}(c_1)$};
    \node [dots, below of=e1] (dots) {$\vdots$};
    \node [subtree, below of=dots] (em) {$\subt{T_n}(c_n)$};
    \node [node, below of=em] [label={-90:$call_{\mathit{fn}}(c_1,\cdots,c_n)$}] (call) {};
    \node [node, right of=call, label={$\mathit{start}$}] (entry) {};
    \node [subtree, below of=entry] (sl) {$B$};
    \node [node, below of=sl, label={-90:$\mathit{exit}(t)$}] (exit) {};
    \node [node, left of=exit, label={$\mathit{result}_{call_{\mathit{fn}}}(c_{tar})$}] (result) {};
    \node [exit, below of=result] (ex) {};

    % Draw edges
    \path [line] (en) -> (e1);
    \path [line] (e1) -> (dots);
    \path [line] (dots) -> (em);
    \path [line] (em) -> (call);
    \path [line] (call) -> (entry);
    \path [line] (entry) -> (sl);
    \path [line] (sl) -> (exit);
    \path [line] (exit) -> (result);
    \path [line] (result) -> (ex);
    \draw [dashed, ->] (call) -- (-2, -8) |- (result);
\end{tikzpicture}\end{adjustbox}
\caption{Function call \label{graph:flowcall}}
\end{graph}


\begin{program}
\begin{lstlisting}
$monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
$monthMap = [];

for($i = 1; $i <= 12; $i++) {
	$monthMap[array_pop($monthNames)] = $i; %* \label{line:pop}*)
}

$input = $_GET["monthName"];

echo $input . " is month number " . $monthMap[$input];
\end{lstlisting}
\caption{Turning a month list into a ``month name to month number''-map}
\label{lst:monthsNoError}
\end{program}

The first step of the analysis is generating the control flow graph. For the array in the first line of this program a CFG node is generated for creating an empty array. Then nodes are generated for each of the 12 initial strings as well as for adding them to the array, when the analysis encounter on of these nodes the empty array will become a list type array since they are represented as array append nodes due to no keys being specified. Lastly the variable name ``monthNames'' will be associated with the initialized list array.

The next interesting step of the analysis is line \ref{line:pop} where an array write node is generated preceded by a sub tree for the expression \texttt{array\_pop(\$monthNames)}. When the analysis encounters the array write node it determines the possible index values for the expression sub tree and since string values are possible the array becomes a map array.

\todo{write something about GET}