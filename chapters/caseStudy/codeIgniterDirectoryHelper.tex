\section{Directory content}
\label{sec:directoryContent}
Found in the CodeIgniter framework, program \ref{lst:directoryMap} demonstrates mixing the map and list type arrays. This programs four library functions for traversing the file-system; \texttt{opendir} which creates a file-pointer for a given directory, \texttt{readdir} which reads the name of the next file/directory in the given directory using the file-pointer, \texttt{is\_dir} which as the name suggests checks if a path is a directory, and \texttt{closedir} which \emph{closes} the file-pointer. Since P0 doesn't support file pointers, these are modelled as numbers in the analysis. 


\begin{program}
\begin{lstlisting}
<?php

function directory_map($source_dir, $directory_depth)
{
    if ($fp = opendir($source_dir))
    {
        $filedata = [];
        $new_depth	= $directory_depth - 1;
        while (FALSE !== ($file = readdir($fp)))
        {
            if (($directory_depth < 1 || $new_depth > 0) && is_dir($source_dir.$file))
            {
                $filedata[$file] = directory_map($source_dir.$file, $new_depth); %* \label{line:directoryMap-1} *)
            }
            else
            {
                $filedata[] = $file; %* \label{line:directoryMap-2} *)
            }
        }
        closedir($fp);
        return $filedata;
    }

    return FALSE;
}

$result = directory_map("testDir", 2);
\end{lstlisting}
\caption{Directory content example}
\label{lst:directoryMap}
\end{program}


The \texttt{directory\_map} function takes a directory name and a depth as input and returns the structure of the given directory recursively bound by the provided length. The resulting structure is a mix of a list of file names and a map from sub directory name to the structure of that sub directory. Mixing a list array and a map array like seen in program \ref{lst:directoryMap} provides no obvious way of using the output of the function, and it seems to assume that directories can't have integers as names. If a directory had a integer, $i$, as a name and more than $i$ files has been seen, then adding the new folder will will override a file already added to the list. E.g.\ let a directory contain a file named \texttt{file1} and an empty subdirectory named \texttt{0}. If \texttt{readdir} first returns the name of the file and then the folder, the result will be \texttt{[[]]} (a list containing an empty list), if the order is reversed, the result will be \texttt{["file1", []]}.

This is a good example of how arrays in PHP serve as the go-to data-structure, when other alternatives might suit the problem better. In this case, representing the files and directories as objects would solve the problem.


The analysis raises three warnings on two code-locations, see figure \ref{fig:directoryScreenshot}. Just as the previous case, these warnings seem to have been raised as side-effects of the real problem, which is caused by the \texttt{\$filedata} array being represented as a map at line \ref{line:directoryMap-1}, a list at line \ref{line:directoryMap-2}, and joined at the end of the \texttt{if}-statement. This join yields the $\top$ array which is the source of the last warning in at both code-locations: \textit{"Target of write might be non-array"}, since it causes all heap locations to be updated when writing to \texttt{\$filedata}. Yielding a warning when a join yields a $\top$ array might be a better indicator on what the \textit{real} problem is.

\begin{figure}
\centering
\begin{subfigure}{\textwidth}
\centering
\includegraphics[width=0.9\textwidth]{chapters/caseStudy/screens/dir1}
\subcaption{Writing with string on list and type mismatch}
\label{fig:directoryScreenshot1}

\end{subfigure}
\begin{subfigure}{\textwidth}
\centering
\includegraphics[width=0.9\textwidth]{chapters/caseStudy/screens/dir2}
\subcaption{Appending a string and type mismatch}
\label{fig:directoryScreenshot2}

\end{subfigure}
\caption{Running analysis on \texttt{directory\_map}}
\label{fig:directoryScreenshot}
\end{figure}

As mentioned above, the files and folders could be represented as objects in order to solve the problem. Since however P0 don't support objects, these can be \textit{emulated} with arrays. In program \ref{lst:directoryMapFixed} the result is a map from file-names to maps representing files and folders. The file- and folder-array has key \texttt{"type"} pointing to \texttt{"file"} and \texttt{"dir"} respectively, and if the \texttt{\$directory\_depth} isn't exceeded, then the folder-array also has key \texttt{"content"} pointing to a list representing the content of the folder, or \texttt{FALSE} if the folder could not be opened.  This solution will successfully represent a given folder independent of which order the folder is read in \texttt{readdir}.


\begin{program}
\begin{lstlisting}
<?php

function directory_map($source_dir, $directory_depth)
{
    if ($fp = opendir($source_dir))
    {
        $filedata = [];
        $new_depth	= $directory_depth - 1;
        while (FALSE !== ($file = readdir($fp)))
        {
            if (is_dir($source_dir.$file))
            {
                $dir = ['type'=>'dir'];
                if($directory_depth < 1 || $new_depth > 0){
                    $dir['content'] = directory_map($source_dir.$file, $new_depth);
                }
                $filedata[$file] = $dir;
            }
            else
            {
                $filedata[$file] = ['type'=>'file'];
            }
        }
        closedir($fp);
        return $filedata;
    }

    return FALSE;
}

$result = directory_map("testDir", 2);
\end{lstlisting}
\caption{Fixed directory content example}
\label{lst:directoryMapFixed}
\end{program}
