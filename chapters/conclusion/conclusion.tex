%First summary then overall conclusion


In this theses, a corpus consisting of some of the most popular PHP frameworks has been run and subsequently analysed, revealing that PHP arrays can in fact be categorized into two types; acyclic lists and maps. Furthermore it was shown that operations normally associated with lists, e.g. \texttt{array\_pop}, \texttt{array\_push}, \texttt{array\_shift}, etc., are used almost exclusively on list-arrays. Running these programs relies on the test-suite defined by the designers of the respective frameworks, which reduces the task of analysing the corpus to adding a logging feature to the interpreter and inspecting the output. While this strategy relies on quality of the given test-suite, the size of the log-files generated (41 MB to 13 GB) and the popularity of the programs, assure us that the coverage achieved, is better than anything we could have designed.


The results of the dynamic analysis motivated the design of a classical inter-procedural data-flow analysis using the monotone framework. In this respect the main contributions  are the definition of a subset language of PHP, a method of generating control-flow graphs, a context sensitive lattice expressing abstract states, and a set of argumentatively sound transfer functions. This analysis has been integrated into one of the most popular IDE for PHP programming, utilizing the AST generated by the environment and allowing instantaneous annotation of code. 

While the analysis is neither proven sound, optimized for fast execution, nor executed on large programs, it has successfully annotated suspicious usage of arrays on code, rewritten to P0, discovered in the corpus in a reasonable time. This analysis serves as a steppingstone to the construction of a full-fledged static analysis of the obscure language that is PHP, and by building this analysis on basic static analysis principles, other techniques for achieving e.g. dynamic dispatch should be relatively easy to apply. 







%The purpose of the dynamic analysis was to evaluate our hypothesis stating that arrays in a given program can be categorized as either list, map, or object, and once categorized, will stay in the category throughout multiple executions of that program. The results of the analysis supports this hypothesis by showing that arrays generally keep the same type. Furthermore, the usage of array operations normally associated with lists, proved almost exclusive for arrays categorized as lists. This information should used to define unexpected behaviour reported by the static analysis, e.g. reporting \texttt{array\_pop} preformed on a map. 

%The initial definitions categorized arrays as objects based on the type of the values. In the analysis however, a significant number of arrays turned out to be lists with different type values, defining them as objects. Operations on these objects were often list-operations, which indicates that categorizing based on value type might not be a meaningful strategy. It can be considered if the object type is providing enough significant information in itself, or should be consumed by the definitions of maps and lists, i.e. letting maps and lists allow values of different type.

%Almost every framework in the corpus contains cyclic arrays however these are nearly exclusively uses of the superglobal \texttt{\$GLOBALS}. Manipulating the global variables as a method for passing information seems suspicious and indicates poor program design, but reminds us that every PHP program has at least one cyclic array which must be handled in an sound manner. No creation of cyclic arrays has been detected in the program, which follows our hypothesis, that the developer will generally not utilize the more advanced array structures. 
 
 
 
%The widely used array data structure in PHP has very few restrictions making it difficult to reason about with program analysis. 

%This thesis will identify possible use-patterns for arrays in PHP 
%and how to detect them in static analysis. 
%An \emph{interprocedural data-flow type-analysis} is proposed to detect suspicious cross-use of the identified patterns.
%And consequently evaluated.
