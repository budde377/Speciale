\section{Precision}
\label{sec:future2}
The abstraction of a static analysis, based on the monotone framework, is done in two places. In the lattice used to represent the state of the analysis and the transfer functions or abstract operations used to transition between different lattice elements to represent changes of the program state. These abstractions are where precision is traded for other properties of the analysis like performance and ease of implementation. In the following some improvements to the lattice and transfer functions are discussed. All improvements should be subject to evaluation on \textit{real} programs, which, as previously stated, would require a larger range of language features to be supported by the analysis. 

Each element of the lattice represents either a certain value or a predicate restricting possible values, e.g. the string \texttt{"foo"} can be represented as a concrete value (not uint string: \texttt{"foo"}), as uIntString or as $\top$-string. The analysis developed in this thesis is path-insensitive. As such the analysis lattice represents only a single predicate, i.e. whether strings, numbers, and array indices are positive integers or not. Otherwise exact values are kept where possible. 

Currently the Integer-lattice, which is part of the Index-lattice, has no predicates, besides the $\top$-integer. By mimicking the separation between unsigned integer and not unsigned integer from the Number and String lattices, differentiation between maps and lists might become more precise, since writes with non-negative integer keys would produce lists and otherwise a map will be produced. Alternatively the predicates of numbers and string could be redesigned to express integer and not-integer strings and numbers, keeping in touch with the current definitions of array-lists and -maps (definition \ref{def:newList} and \ref{def:newMap} respectively). 

Another immediate improvement of the lattice would be to introduce a new parent to ArrayList and ArrayMap in the Array lattice, as proposed in section \ref{sec:caseConcl}. By keeping track of the locations of an array, even when it is not a list nor map, would most likely provide enormous precision. Notice that this would also remove many of the errors raised from performing operations on the $\top$-array element, observed throughout the cases presented on chapter \ref{ch:evaluation}, and thus another method for alerting precision loss should be implemented. 

Because of PHP keeping references when copying arrays the analysis can not soundly perform strong updates on the heap. Assigning references from arrays may however be one of the less used features of PHP. A hypothesis about the use of references in arrays can be tested by expanding the dynamic analysis in chapter \ref{ch:study}. If references in arrays turn out to be rarely used strong updates could be reintroduced thus sacrificing soundness. Alternatively the heap could have an associated entry expressing whether any given location has been referenced. This would model the implementation of the interpreter more precisely, and should allow strong updates on some locations.


 