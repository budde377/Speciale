\section{Supporting the full PHP language}
\label{sec:future1}
The static analysis developed in this thesis supports a subset of PHP (P0) as defined in chapter \ref{ch:analysis}. Section \ref{sec:langsubset} defines the restricted syntax and semantics of P0, omitting most dynamic features of PHP and non-obvious usage of operators. 

\subsection{Operators}
Since variables are not restricted to a single type throughout a PHP program and there are no static types a lot of cross-type operations are allowed, e.g. comparing a boolean with a string using \texttt{<=}. P0 removes support for some of these cross-type operations because they are not defined in an intuitive way. As an example the unary increment and decrement operators can be applied to strings. Listing \ref{lst:incDec} demonstrates how diferent strings are incremented. If the last character is a letter from a-y (always keeping the current case), that letter will be turned into the following letter in the alphabetical order. If the last letter is a z it will turn into an a as well as recursively applying the increment operation to the previous letter as well. If no previous letter exists an a will be prepended to the string. Any character that is not a letter from a-z will stop the increment operation and stay unchanged. While this definition seems somewhat sensible intuitively the decrement operator should then do the opposite of increment, however that is not the case. Applying the decrement operators to a string never changes the initial string.

\begin{program}
\begin{lstlisting}
$a = "a";
$b = "Bob";
$c = "Z";
$d = "Hello World!";
$a++; // Result: "b"
$b++; // Result: "Boc"
$c++; // Result: "AA"
$d++; // Result: "Hello World"
// Decrementing does nothing
\end{lstlisting}
\caption{Increment and decrement operators used with strings}
\label{lst:incDec}
\end{program}

To be able to support all these operations in a sound manner the official PHP interpreter has to be studied to create an overview of how each operation is implemented and thus defined. The interpreter is the only definition of the PHP language yet, even though the work at an official definition is in progress \citeA{phpLangSpec}. Until the official definition of the language is created, inspecting the interpreter source code is the only way to get a full overview of how operators are implemented and using that overview to create a full set of abstract operators from value lattice element to value lattice element.



\subsection{Dynamic features}
The language subset P0 does not support variable variables, variable functions, or dynamic loading of code. One way of supporting variable variables is to change the definition of the local and global scope lattices. Instead of mapping from variable names they could be maps from strings to heap-locations allowing an abstract operation for look-up in the global and local variable scopes. Supporting variable variables have the will impact precision in cases containing many writes to variable variables with names that cannot be reasoned about statically. Any write to a $\top$-element string has to be joined when reading from all variables which lowers the precision of all variable reads.

Supporting variable variables will also introduce some of the problems encountered when implementing the array-map. For example, a reference assignment to a variable is currently updated strongly, just as a reference assignment to an array, this would however not always be sound with variable variables.

In order for the analysis to support the whole language, resolving functions dynamically must also be supported. This follows from the special functions \texttt{call\_user\_func} and \texttt{call\_user\_func\_array} and the so called \emph{callables}, which are strings, arrays, or anonymous functions that represent a function. For example, let function \texttt{f()} be defined, then calling the string \texttt{"f"} is equivalent to calling the function directly. Resolving functions dynamically could possibly be implemented using existing methods for supporting dynamic dispatch on e.g. objects.

As mentioned in section \ref{sec:bgProgStuc}, dynamically loading code with the \texttt{include} or \texttt{require} statements shouldn't practically impose a problem, since modern PHP programs tend to use the auto-loading features of dependency managers. Another method for dynamically loading code is the \texttt{eval} function, which evaluates the PHP code in a given string. Adding support for this feature should be done inspired by existing work for the JavaScript \texttt{eval} function.

\subsection{Objects and resources}	
This thesis has completely ignored a large part of PHP, namely the object model. To be able to handle real PHP application objects must be supported since almost every PHP application is at least partly object oriented. Since objects are dynamic as the rest of PHP, properties can be added and removed at execution time. To keep soundness of the analysis object properties can be modelled as a map array. This approach suffers from the same weakness as variable variables, that writes to $\top$-element property names lessens the precision of all other properties. By expanding the dynamical analysis from chapter \ref{ch:study} to log object property creations and removals a hypothesis about these operations being rare can be tested. If such a hypothesis turns out to be true an unsound disregard of property creations and removals can be applied in the analysis. Which will in turn heighten the precision of the analysis.

The Value-lattice in this thesis does not support the PHP resource type. It is a special type used for handling references to external resources like files or database connections, which are used by most real applications. To support the resource type, an abstraction in the form of a lattice must be created and added as another factor in the Value-lattice. Further more operators and coercion must be expanded to the resource type as well.

\subsection{Library functions}
The huge library of functions packaged with PHP by default is essential to any real application. To be able to handle real application all of these functions must be supported with at least a naive, imprecise transfer function. Functions without any side-effects, i.e. without reference-parameters, can be naively supported by resulting in the $\top$-element value. Functions with possible side-effects further more have to join the heap locations values of the reference parameters with the $\top$-element value. By adding these naive transfer-functions for library functions the analysis will keep soundness for any use of library functions at the cost of losing a lot of precision. The soundness argument here is based on an assumption that library functions do not have side-effects except for possible manipulation of reference-parameters. Since library functions are implemented using an API provided by the interpreter they may have side-effects, however we have not observed any functions with such side-effects and thus find it fair to assume they do not exist. To keep a higher precision each library function must be examined and abstracted into a sound transfer-function.

\subsection{Special language constructs}
Function-like language constructs are not supported in P0, however most real programs rely on at least some of these constructs. In program \ref{lst:languageConstructs} the \texttt{isset}, \texttt{unset}, \texttt{empty} and \texttt{exit} constructs are demonstrated. The most straight-forward construct is \texttt{empty}, since it takes ordinary expressions as input just like any function. A transfer function must be specified, like for library functions, to support \texttt{empty}. The constructs \texttt{isset} and \texttt{unset} accept variable-expressions only as parameters. Unsetting can be abstracted by joining with the \texttt{Null}-value, since that is the value of unset variables and unset array entries. Implementing \texttt{isset} naively is simple, however to get more precision the implementation of \texttt{unset} has to be taken into account, since unsetting a variable will result in \texttt{isset} for that variable returning boolean true. 

\begin{program}
\begin{subfigure}[b]{.45\linewidth}
    \begin{lstlisting}
    $a = 0;
    $b = 42;
    empty($a); // true
    empty($b); // false
    empty($c); // true
    isset($a); // true
    isset($b); // true
    isset($c); // false
    unset($b);
    isset($b); // false
\end{lstlisting}
    \caption{Isset, unset, and empty}
\end{subfigure}
\begin{subfigure}[b]{.50\linewidth}
    \begin{lstlisting}
    $a = 1;
    $b = 2;
    exit();
    $c = 3; // unreachable
\end{lstlisting}
    \caption{Exit}
\end{subfigure}
\caption{Function-like language constructs}
\label{lst:languageConstructs}
\end{program}

\subsection{Other unsupported features}

\todo{cast, array acces on strings etc.} 

\todo{are we missing any other features?}