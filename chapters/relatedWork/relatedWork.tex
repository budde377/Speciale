As it might have become evident throughout this thesis, PHP supports many dynamic features, most of which has been omitted in this analysis, due the focus being on arrays. Just as an analysis of popular PHP frameworks has been performed in this thesis, with focus on arrays,  \citeA{featureUsage13} and \citeA{dynamicfeatures15} analyse which dynamic features are commonly used. In \citeA{richards10}, a similar dynamic analysis is used to determine the behavior of JavaScript programs. The approach taken is different from our approach in that they record ``meaningful'' interactions with corpus websites, whereas our dynamic analysis relies on test suites provided by the corpus applications

WeVerca, presented in \citeA{weverca14},  is a framework for designing static analysis of PHP. This provides the control-flow, the heap shape, and dynamic data access directly to the designer, which in turn allows the designer to implement a static analysis independently of these features. WeVerca uses the Phalanger parser, which currently supports up to PHP 5.4. With the aim of designing an analysis supporting PHP 5.6, using WeVerca was discarded as an option early on.

In \citeA{associativeArrays14}, variable variables are supported by treating the global scope of PHP as an array with keys corresponding to the names of variables. Accessing variable variables is then a simple matter of how array access is handled in general.

Dynamically loading PHP files, e.g.\ using the \texttt{require} and \texttt{include} statements, is considered by \citeA{includesResolution}, which provides a technique for statically resolving includes in PHP. This is done by first using a file-centered context-less algorithm to find possible file matches and then refining the results with a context sensitive program-centered algorithm. 

The concept of references in PHP complicates reasoning about PHP programs. In \citeA{copyOnWrite09}, the copy-on-write practice exhibited by the official PHP interpreter is investigated and compared to the stated copy-on-assignment semantics of the PHP documentation. In \citeA{associativeArrays14},  references are treated  by implementing a data-flow analysis using a concept of aliases. 


JavaScript is similar to PHP in many ways. The static analysis provided by this thesis is inspired by TAJS \citeA{tajs09}, a type analysis for JavaScript. As opposed to PHP, JavaScript does not deep-copy arrays. TAJS makes use of pointers in its Value-lattice for arrays and objects whereas the analysis in this thesis includes arrays directly in the Value-lattice.

Pixy \citeA{pixy06} is a static analysis tool aimed at detecting security vulnerabilities. The tool is limited to PHP 4, which is a long out-dated version of PHP, neither developed nor supported anymore. The analysis developed in this thesis aims to support PHP 5.6, which is the newest version as of the time of writing.

Blended analysis is a different approach to utilizing dynamic analysis. In \citeA{blendedtaint}, a dynamic analysis is used to prune unused and impossible paths, effectively speeding up the performance of a subsequent static taint analysis. Furthermore, the pruned paths have the possibility of removing false positives from the static analysis result. However, as stated by \citeA{blendedanalysis}, utilizing dynamic analysis this way requires some kind of restriction on possible inputs for the programs, as each input has to be run by the dynamic analysis. %Our approach utilizes the dynamic analysis to make well-founded choices about trading precision or soundness for performance in a static analysis.


Each program analysis of course has its own specific purposes. It is, however, possible to place the common purposes of program analysis into a few broader categories. Many analyses like \citeA{artzi10} and \citeA{minamide05}, are concerned with finding security flaws or other types of bugs. It is also possible to use program analysis to prove conformity to a specification. The findings of our analysis is not per se bugs, since the program in question may work to specification despite our analysis generating errors or warnings. Instead our analysis concerns clarity of intention and maintainability. In the end, these properties also lead to code in which bugs are easier to find. The following works relate to this thesis in the sense that our analysis complements those analyses well.

The analysis in \citeA{artzi10} employs a strategy of dynamic test generation and explicit-state model checking to be able to find bugs resulting in execution errors or malformed HTML output. By dynamically creating path constraints the analysis covers possible execution paths and is then able to report possible malformed output.

Another approach to finding malformed HTML output is taken by \citeA{minamide05}. Using an analysis that generates a context-free grammar describing the possible output of a program, it is possible to check this output against a regular language describing valid HTML strings with a bounded tag-nesting.

Detection of cross-site scripting vulnerabilities is a popular topic for analyses of PHP. In \citeA{minamide05}, it is proposed to detect occurrences of the \texttt{<script>}-tag and report these as cross-site scripting vulnerabilities. In \citeA{wassermann08}, the detection of these vulnerabilities is taken a step further, trying to compensate for browsers allowing malformed HTML which may lead to finding vulnerabilities undetected by other approaches.