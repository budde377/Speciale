In order to analyze how arrays are used throughout a log file, some method for identifying which arrays are mentioned on a given line is needed. E.g. in the output \ref{lst:id_array_code_out} all lines are concerning the same array with memory address \texttt{0x539}. Here identifying these arrays as the same, is a matter of checking the address. Due to the size of the test suites, relying only on the address is not a stable approach. Over time addresses will be reused and false identifications will happen. This issue can be solved by depending on the \texttt{hash\_init} line, which indicates that the a new array is initialized at some address. If such a line occurs between two usages of an address they can not necessarily be considered representing the same array. 

Since the log files are generated from running a test-suite, relying on addresses for identification alone, might result in a skewed analysis with an over-representation of arrays occurring in \emph{critical} code. Determining array equality based on initialization location in the file, should provide a more equal representation of arrays, not letting some arrays dominate the statistics. Locational identification would however identify four different arrays in example \ref{lst:id_array_code_out}, which does not reflect the program \ref{lst:id_array_code} and thus the address is still needed to identify the same array across multiple code locations.

\begin{figure}
\centering
\begin{subfigure}{\textwidth}
\begin{lstlisting}[mathescape, deletekeywords={array},basicstyle=\tiny]
hash_init       0x539
array_init      1       a.php       0       1       0       0x539
assign_tmp      1       a.php       NULL    array   1       1       3       0x539
array_append    2       a.php       1       1       3       0x539  long    4
\end{lstlisting}
\caption{Log from running file \texttt{a.php}}
\label{lst:id_array_code_out}
\end{subfigure}
\begin{subfigure}{\textwidth}
\begin{lstlisting}
$a = [1,2,3];
$a[] = 4;
\end{lstlisting}
\caption{File: \texttt{a.php}}
\label{lst:id_array_code}
\end{subfigure}
\caption{Example of the result from a run with the modified interpreter.}
\end{figure}
\begin{definition}
Given two lines, $l_1$ and $l_2$, from a log file, $R$, as described above, each containing an array $x_1\in l_1$ and $x_2\in l_2$, where $x_1 = (t_1,d_1,s_1,a_1)$ and $x_2 = (t_2,d_2,s_2,a_2)$. The arrays are said to be positional equal, $x_1\stackrel{pos}{=} x_2$, iff the two lines share the same line number, line type, and file or $a_1 = a_2$ and there is no 
\begin{align*}
\texttt{hash\_init}\;a_1
\end{align*}
line between $l_1$ and $l_2$.
\end{definition}
This definition utilizes file position and addresses in order to identify arrays. The line type has been added in order to heighten precision, since multiple different operations, on different arrays, may occur on the same line. 
\begin{definition}
Given two lines $l_1, l_2\in R$ and two arrays, $x_1\in l_1$ and $x_2 \in l_2$, then $id$ is a ID-function iff.
\begin{align*}
    id(x_1) = id(x_2) \Leftrightarrow x_1 \stackrel{pos}{=} x_2
\end{align*}
\end{definition}

When iterating through a log file, from top to bottom, IDs can be generated by keeping a mapping from locations to IDs and from addresses to IDs, and by \emph{forgetting} addresses when a \texttt{hash\_init} line is observed.