This section contains the implementation details of the dynamic analysis. The last part of the section discusses flaws and limitations arisen from the chosen implementation of the analysis. The analysis consists of two phases: \textit{test suite execution} with logging of feature usage and \textit{analysis} of the logged data. The test suites are executed on a modified version of the official PHP interpreter to enable logging of feature usage.

\subsection{Logging of feature usage}
All usages of array library functions (\texttt{array\_push()}, \texttt{array\_pop()}, \texttt{array\_search()}, \texttt{count()}, etc.), array reads, array writes, assignments, and every array initialization are logged while executing the test suites. These are logged in a CSV file where each line is a log entry containing information separated by the tab character. All entries begin with  \emph{line type}, which identifies the type of the entry. The possible line types are described in the list below.

\begin{itemize}
\item \emph{array function}: Every call to a library array function\footnote{\url{http://php.net/manual/en/ref.array.php}}, such as \texttt{array\_push()} or \texttt{count()} are logged with the function name as line type. The array functions do not include the \texttt{array()} used to initialize an array, since it is a language construct and not an actual function. Some subroutines are also logged, e.g. \texttt{array\_mr\_part} used by the \texttt{array\_merge} function.
\item \texttt{array\_read}: Every read from an array is logged with the array being read from and the key used as well as the type of the value being.
\item \texttt{array\_write}: All array writes of the form \texttt{\$x[\$key] = \$y} are logged with the array being read from (\texttt{\$x}) the key (\texttt{\$key}). 
\item \texttt{array\_append}: When elements are added to the array using the append method, \texttt{\$x[] = \$y}, this is logged with the array being read from, \texttt{\$x}.
\item \texttt{assign\_*}: Every assignment is logged as either \texttt{assign\_const}, \texttt{assign\_tmp}, \texttt{assign\_var} or \texttt{assign\_ref} depending on whether the value being assigned is a constant, temporary variable, variable or reference respectively.\\
The assignment \texttt{\$x = (string) \$y} is an example of an assignment from a temporary variable. Here the the \texttt{\$y} variable is casted and saved in a temporary variable which then is assigned to \texttt{\$x}. One of these lines always follow \texttt{array\_write} and \texttt{array\_append} and is used to determine the type of value written in those lines.
\item \texttt{array\_init}: When an array is initialized in a function without the static keyword, using either the \texttt{array('key' => 'value')} construct or the corresponding bracket notation, \texttt{['key' => 'value']}, it is logged with the array being created. If the array is initialized in any other way, e.g. as a field or by array write it is not logged with \texttt{array\_init}.
\item \texttt{hash\_init}: Whenever a hash table, the underlying structure of arrays, is initialized, this is logged with the memory address of the table.
\end{itemize}

Arrays are logged as a tuple with four entries, $(t,d,s,a)$, where $t\in T\times C$ is the type of the array, $d$ is the depth of the array, $s$ is the size of the array, and $a$ is the memory address. Here $T = \{\text{List, Map, Sparse List}\}$ and $C = \{\text{Cyclic, Acyclic}\}$. The array type logged indicates the type of keys present in the array as well as whether it contains any self-references. Lists contain sequential integer keys starting from 0, Sparse Lists are any other arrays with only integer keys and Map is all arrays with at least one key of type string. Any array with a self-reference is Cyclic and all other arrays are Acyclic.

Objects are logged as their instance name, integers and floats are logged with their value, string are logged only as \texttt{string}, booleans as $0$ if \texttt{false} otherwise 1, and the null value logged as \texttt{NULL}. Strings are is generally not logged with a value, because doing so increases the file-size drastically, tends to corrupt the file when containing binary data, and has not proven necessary for the analysis.

All entries besides the \texttt{hash\_init} entries contain a line number and a file path to where the action occurred. 

\subsection{Identification of arrays}
\input{chapters/study/id_arrays}

\subsection{Determining type}
\input{chapters/study/det_type}

\subsection{Compiling and running PHP with logging}
For the purpose of the dynamic analysis, Vagrant\footnote{\url{http://vagrantup.com/}} is used to create a clean and reproducible environment. A Vagrant initialization file\footnote{\url{http://github.com/Silwing/tapas-survey}} is used to setup a virtual machine running a 64-bit Ubuntu 14.04, install the necessary dependencies and compile the modified PHP Interpreter. The environment for running the corpus test suites is then ready and can be accessed via SSH on the virtual machine. The folder \texttt{/vagrant/corpus} contains a Makefile which can be used to fetch dependencies and corpus frameworks as well as running all the test suites.

All modifications to the interpreter are guarded by an ini-directive\citeB[Chapter~14.12]{programmingphp} that is disabled by default when compiling and running the modified interpreter source. The logging can be enabled via \texttt{php.ini} or for single runs as seen in figure \ref{fig:iniDirective}

\begin{figure}[ht]
\centering
\begin{subfigure}{\linewidth}
\begin{lstlisting}[language=bash]
$ php -d rb.enable_debug=1 -d rb.enable_debug_file=<path-to-log-file> <path-to-php-file>
\end{lstlisting}
\caption{Enable logging for running a single PHP file.}
\end{subfigure}
\begin{subfigure}{\linewidth}
\begin{lstlisting}
rb.enable_debug=1
rb.enable_debug_file="/path/to/output/csv/file"
\end{lstlisting}
\caption{Enable logging in php.ini.}
\end{subfigure}
\caption{How-to enable logging}
\label{fig:iniDirective}
\end{figure}

\subsection{Discussion}
\input{chapters/study/discussion}