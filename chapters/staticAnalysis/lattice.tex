
\section{Lattice}
%\todo{The keys of PHP arrays can be strings and/or integers. If given an integer string (e.g. "1") the key will be coerced to an integer key. Strings containing an integer as well as other characters well be kept as a string key as opposed to the string to integer coercing with math operators. Taking this fact into consideration it is interesting to support differentiating of Strings and IntegerStrings in our lattice.}
In order to create a inter-procedural analysis, the analysis lattice is defined as
\begin{align}
\text{AnalysisLattice} = \Delta \rightarrow \text{State}
\end{align}
This is a map from a context to an abstract state, where the context, $\Delta$ consists of a list of call-sites, represented as the call nodes in the control flow graph, with length bounded by $k>0$. 
\begin{align}
\Delta = \text{CallNode}_*^{\leq k}
\end{align}
The abstract state is a product lattice with five factors. The first two models the scope, the third the heap, and the last two models storage for intermediate results. 
\begin{align}
\text{State} = \text{Locals} \times \text{Globals} \times \text{Heap} \times \text{Temps} \times \text{HeapTemps} 
\end{align}
As described, in section \ref{sec:backg_scoping}, the scoping rules of PHP are very simple and can be expressed with a global and a local scope. The global scope is necessary, because global variables can always be accessed from a function using the \texttt{global} statement. Furthermore the super-global variables resides in the global scope but can always be accessed directly. Only two scopes is enough, because any other variables has to be passed to a function as an argument. This is even the case for anonymous functions, where however the \texttt{use} keyword can be used to pass variables to a function when defining the function.
\begin{align}
\text{Locals} = \text{Globals} = \text{Scope} = \text{Var} \rightarrow \mathcal{P}(\text{HLoc})
\end{align}
The scopes are defined as maps from variable names, {\bf Var}, to power-set of heap locations $\mathcal{P}(\text{\bf HLoc})$. While PHP supposedly performs deep copies of values on assignments, letting the scope be a map from variable names to values would not facilitate feature of assigning references to and from variables and array entries. This is done using the \texttt{\&} operator and makes the heap abstraction is necessary. The heap allows values to be used by multiple variables and arrays which enables properly propagation of changes. 
\begin{align}
\text{Heap} = \text{HLoc} \rightarrow \text{Value}
\end{align}
The {\bf Temps} and {\bf HeapTemps} are for storing intermediate results. Since these results cannot be referenced there is no need to store them in the heap. By keeping them in a seperate lattice, they can be strongly updated and does not have to, and should not, be passed when switching context, since they are in every respect local to the current context. A single temporary storage mapping from temporary variables to a sum-lattice of values and power-set lattice was considered, this however would involve special handling of $\top$ and $\bot$ elements, which is avoided by this method. 
\begin{align}
\text{Temps} = \text{TVar} \rightarrow \text{Value}
\end{align}
\begin{align}
\text{HeapTemps} = \text{THVar} \rightarrow \mathcal{P}(\text{HLoc})
\end{align}
The necessity for the latter lattice follows from the fact that reference assignments may be nested, which requires intermediate results shared between nodes in the control-flow graph. The sets of temporary variables, {\bf TVar} and {\bf THVar}, are both finite, following from the control-flow-graph being finite.

The heap locations are allocation site abstractions wrt. context, node, and a natural number. Adding the natural number as a factor makes the set of allocation sites possibly infinite, in practise however the set is finite. 
\begin{align}
\text{HLoc}  = \Delta \times \mathcal{N} \times \mathbb{N}
\end{align}
Where $\mathcal{N}$ is the set of nodes in the control flow graph. 

An abstract value is defined a product lattice with five factors defined by the Hasse diagrams shown in figure \ref{fig:hasse_lat}. These lattices was chosen with the hope of better coercion between values, but others might be considered. E.g. by focusing more on coercion from strings to array indices.
\begin{align}
\text{Value} = \text{Array} & \times \text{String} \times \text{Number} \times \text{Boolean}  \times \text{Null}
\end{align}
Following the results of the dynamic analysis in \label{ch:study}, the array is considered either a set of locations or a map from indices to sets of types. I.e. lists or maps. The sum-lattice has been chosen as opposed to a product-lattice, following the study in chapter \ref{ch:study}, which indicates that arrays seldom changes from lists to maps or vice versa. Top array elements is then a predictor for suspicious behavior. Furthermore the array lattice has an element for the empty array which can become either a list or a map.  
\begin{align}
\text{ArrayList}= \mathcal{P}( L )
\end{align}
\begin{align}
\text{ArrayMap}=\text{Index} \rightarrow \mathcal{P}( L )
\end{align}
The indices of the map-array is an infinite lattice yielding a possibly infinite array-map. Assuming that an infinite sized array existed, this would require an infinite number of writes to a map, which in turn would require an infinite sized program, a recursive function, or a loop. Because of the infinite program is not being possible one of the latter cases must hold. Assuming the cause is a recursive function, then because of a finite number of contexts and allocation sites abstracting the indices is bound to happen and cannot cause an array of infinite size. Now assuming that the array is caused by a loop, then the indices must be generated from previous iterations, meaning that they are generated from information stored on the heap. With a finite number of heap locations and no strong heap update, the indices must be abstracted, thus not yielding an array of infinite size.
\begin{align}
\text{Index} = \text{String} + \text{Integer}
\end{align}
\tikzcdset{tips=false}
\begin{figure}
\centering

\begin{subfigure}{0.25\linewidth}
Null = \begin{tikzcd}
\text{null}\ar{d}\\
\bot
\end{tikzcd}
\end{subfigure}
\begin{subfigure}{0.5\linewidth}
Bool = 
\begin{tikzpicture}[baseline= (a).base]
\node[scale=.7] (a) at (0,0){
\begin{tikzcd}
&\top\ar{dl}\ar{dr}\\
\text{true}\ar{dr} & & \text{false}\ar{dl}\\
& \bot
\end{tikzcd}};
\end{tikzpicture}
\end{subfigure}
\begin{subfigure}{0.8\linewidth}
Number = 
\begin{tikzpicture}[baseline= (a).base]
\node[scale=.7] (a) at (0,0){
\begin{tikzcd}
&\top\ar{dl}\ar{dr}\\
\text{uInt}\ar[d,dashed] & & \text{notUInt}\ar[d, dashed]\\
\{0,1,2,\cdots \}\ar[dr, dashed]&  & \{\cdots,-1, -41, 0.1, 0x123\cdots\}\ar[dl, dashed]\\
&\bot
\end{tikzcd}};
\end{tikzpicture}
\end{subfigure}
\begin{subfigure}{0.8\linewidth}
String = 
\begin{tikzpicture}[baseline= (a).base]
\node[scale=.7] (a) at (0,0){
\begin{tikzcd}
&\top\ar{dl}\ar{dr}\\
\text{uIntString}\ar[d,dashed] & & \text{notUIntString}\ar[d, dashed]\\
\{"0","1","2",\cdots \}\ar[dr, dashed]&  & \{\cdots,"-1", "-41", "foo", "bar"\cdots\}\ar[dl, dashed]\\
&\bot
\end{tikzcd}};
\end{tikzpicture}
\end{subfigure}
\begin{subfigure}{0.8\linewidth}
Array = 
\begin{tikzpicture}[baseline= (a).base]
\node[scale=0.9] (a) at (0,0){
\begin{tikzcd}
& \top \ar[dr]\ar[dl]\\
ArrayList\ar[dr] & & ArrayMap\ar[dl]\\
& \text{emptyArray} \ar{d}\\
& \bot
\end{tikzcd}};
\end{tikzpicture}
\end{subfigure}
\begin{subfigure}{0.6\linewidth}
Integer = 
\begin{tikzpicture}[baseline= (a).base]
\node[scale=0.9] (a) at (0,0){
\begin{tikzcd}
\top \ar[d, dashed]\\
\{\cdots, -2, -1, 0,1,2,\cdots \}\ar[d, dashed]\\
\bot
\end{tikzcd}};
\end{tikzpicture}
\end{subfigure}
\caption{Hasse diagrams of lattices}
\label{fig:hasse_lat}
\end{figure}
%\todo{Any integer string, also negative ones, will be coerced to an integer when used as array index, currently our implementation does not coerce negative integer strings}
%\todo{toNumber does coerce negative integer strings.}
%\todo{In PHP the expression of an if-condition will be coerced to a boolean value. If the lattices supports differentiating between value coercing to boolean true and values coercing to boolean false it is possible to reason about variables used as if-conditions.}

%\todo{Aliasing: Pointer analysis!}