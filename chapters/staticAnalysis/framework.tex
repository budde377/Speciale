\section{The Monotone Framework}
\todo{global arrays GET, POST and COOKIE are initialized as maps with map or string values. Depth 1 is implemented, but arbitrary depth could be implemented easily. SESSION is a top array since anything can be stored in it and will be automatically serialized/unserialized between requests. FILES is a map of maps, each inner map providing data about the corresponding uploaded file}

\todo{describe the monotone framework and how the informal CFG + transfer functions apply}

\todo{Write about initial lattice (Super globals + hloc)}

\todo{All Variables should map to NULL initially}

\todo{How is the lattice compared properly with an infinite domain of variables set to NULL}
\clearpage
\section{Control flow graph}
\tikzstyle{subtree} = [rectangle, draw, fill=gray!20, text width=4em, text badly centered, minimum height=3em]
\tikzstyle{node} = [draw, circle, minimum height=2em]
\tikzstyle{emptynode} = [draw, circle]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{entry} = [draw=none,fill=none]
\tikzstyle{exit} = [draw=none,fill=none]
\tikzstyle{dots} = [draw=none,fill=none]
Given a P0 program, $p : \syn{program}$, parsed to a abstract syntax tree, the control flow graph can be constructed recursively. Every graph has an entry and an exit node. The control-flow graph created from $p$ consists of the control-flow graphs for each statement in $p$ connecting each sub-graph with edges from exit to entry nodes. The order of execution is preserved. 
\subsection{Statements}
Let $s : \syn{statement}$ be a statement, then there are nine different graphs, one for each case in the grammar \ref{gramm:p0}. The first four, for $s = $ \texttt{while($E$) $S$}, $s = $ \texttt{for($E_1$;$ E_2$;$E_3$) $S$}, $s = $ \texttt{if($E$) $S$}, and $s = $ \texttt{if($E$) $S_1$ else $S_2$} statements, are depicted as figure \ref{fig:flowwhile}, \ref{fig:flowfor}, \ref{fig:flowif}, and \ref{fig:flowifelse} respectively. In the graphs the nodes are circles with an associated label indicating the node type, and the grey rectangles are sub-graphs. Notice how the expression-sub-graph takes a temporary variable, $t$, as argument. This indicates where the result of evaluating the expression should be stored in the temporary storage of the lattice. 


\begin{figure}
\hspace*{\fill}
\subcaptionbox{\label{fig:flowwhile}}{\begin{adjustbox}{max size={.25\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree, below of=en] (e1) {$E(t)$};
    \node [node, below of=e1, label={0:$if(t)$}] (if) {};
    \node [subtree, below of=if ] (s1) {$S$};
    \node [emptynode, below of=s1 ] (end) {};
    \node [exit, below of=end] (ex) {};

    % Draw edges
    \path[line] (en) -> (e1);
    \path [line] (e1) -> (if);
    \path [line] (if) -> (s1);
    \path [line] (if) -- (-2, -4) |- (end); 
    \path [line] (s1) -- (2, -6) |- (e1); 
    \path [line] (end) -> (ex);
\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{\label{fig:flowfor}}{\begin{adjustbox}{max size={.25\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    
    \node [entry] (en) {};
    \node [subtree, below of=en] (e1) {$E_1(\_)$};
    \node [subtree, below of=e1] (e2) {$E_2(t)$};
    \node [node, below of=e2, label={135:$if(t)$}] (if) {};
    \node [subtree, below left of=if] (s) {$S$};
    \node [subtree, below right of=if] (e3) {$E_3(\_)$};
    \node [emptynode, below right of=s] (end) {};
    \node [exit, below of=end] (ex) {};
    
    % Draw edges
    \path [line] (en) -> (e1);
    \path [line] (e1) -> (e2);
    \path [line] (e2) -> (if);
    \path [line] (if) -> (s);
    \path [line] (s) -> (e3);
%    \path [line] (e3) -> (end);
    \path [line] (end) -> (ex);
    \path [line] (e3) |- (e2);
    \path [line] (if) -- (-3, -6) |- (end);
\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{\label{fig:flowif}}{\begin{adjustbox}{max size={.25\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    
    \node [entry] (en) {};
    \node [subtree, below of=en] (e1) {$E(t)$};
    \node [node, below of=e1, label={45:$if(t)$}] (if) {};
    \node [subtree, below of=if] (s1) {$S$};
    \node [emptynode, below of=s1](end) {};
    \node [exit, below of=end] (ex) {};
    
    % Draw edges
    \path [line] (en) -> (e1);
    \path [line] (e1) -> (if);
    \path [line] (if) -> (s1);
    \path [line] (s1) -> (end);
    \path [line] (if) -- (2,-4) |-  (end);
    \path [line] (end) -> (ex);
\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{\label{fig:flowifelse}}{\begin{adjustbox}{max size={.25\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree,below of=en] (e1) {$E(t)$};
    \node [node, below of=e1, label={35:$if(t)$}] (if) {};
    \node [subtree, below left of=if] (s1) {$S_1$};
    \node [subtree, below right of=if] (s2) {$S_2$};
    \node [emptynode, below right of=s1](end) {};
    \node [exit, below of=end] (ex) {};
    % Draw edges
    \path[line] (en) -> (e1);
    \path [line] (e1) -> (if);
    \path [line] (if) -> (s1);
    \path [line] (if) -> (s2);
    \path [line] (s1) -> (end);
    \path [line] (s2) -> (end);
    \path [line] (end) -> (ex);
\end{tikzpicture}\end{adjustbox}}
\hspace*{\fill}
\end{figure}

For $s =$ \texttt{global $v_1,\cdots, v_n$} the graph is containing a single, $global$, node which takes the variable names $v_1,\cdots v_n$ as argument. For $s =$ \texttt{return $e$} statement there are three possible graphs. If the return statement is empty, i.e. does not contain an expression, then this is equivalent of returning \texttt{null}



\begin{figure}
\hspace*{\fill}
\subcaptionbox{\label{fig:flowwhile}}{\begin{adjustbox}{max size={.25\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [node, below of=en, label={135:$const_r(null, t_{tar})$}] (const) {};
    \node [node, right of=const, label={-90:$exit(\cdots, t_{tar}, \cdots)$}] (exitn) {};
    \node [emptynode, below of=const ] (end) {};
    \node [exit, below of=end] (ex) {};
      % Draw edges
    \path[line] (en) -> (const);
    \path[line] (const) -> (exitn);
    \path[line] (end) -> (ex);
    
\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{\label{fig:flowfor}}{\begin{adjustbox}{max size={.25\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    
    \node [entry] (en) {};
    \node [subtree, below of=en] (e1) {$E_1(\_)$};
    \node [subtree, below of=e1] (e2) {$E_2(t)$};
    \node [node, below of=e2, label={135:$if(t)$}] (if) {};
    \node [subtree, below left of=if] (s) {$S$};
    \node [subtree, below right of=if] (e3) {$E_3(\_)$};
    \node [emptynode, below right of=s] (end) {};
    \node [exit, below of=end] (ex) {};
    
    % Draw edges
    \path [line] (en) -> (e1);
    \path [line] (e1) -> (e2);
    \path [line] (e2) -> (if);
    \path [line] (if) -> (s);
    \path [line] (s) -> (e3);
%    \path [line] (e3) -> (end);
    \path [line] (end) -> (ex);
    \path [line] (e3) |- (e2);
    \path [line] (if) -- (-3, -6) |- (end);
\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{\label{fig:flowifelse}}{\begin{adjustbox}{max size={.25\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree,below of=en] (e1) {$E(t)$};
    \node [node, below of=e1, label={35:$if(t)$}] (if) {};
    \node [subtree, below left of=if] (s1) {$S_1$};
    \node [subtree, below right of=if] (s2) {$S_2$};
    \node [emptynode, below right of=s1](end) {};
    \node [exit, below of=end] (ex) {};
    % Draw edges
    \path[line] (en) -> (e1);
    \path [line] (e1) -> (if);
    \path [line] (if) -> (s1);
    \path [line] (if) -> (s2);
    \path [line] (s1) -> (end);
    \path [line] (s2) -> (end);
    \path [line] (end) -> (ex);
\end{tikzpicture}\end{adjustbox}}
\hspace*{\fill}
\end{figure}


The fifth graph is the empty graph, the sixth is the graph of the expression, and the ninth graph is the graph of the block statement, which is the consisting of each statement in the block connected by edges in the right order.


\subsection{Expressions}

\subsection{Function definitions}

\clearpage
\begin{comment}

\todo{rewrite}
Control flow graphs defines how a program might be executed. The elementary blocks of the program is represented by nodes in the graph and the possible execution flows is represented by edges. To keep track of calculations across different nodes the temporary storage is utilized. Program variables are denoted with $v_j \in Var$, expressions with $E$, statements with $S$, and a block of statements is denoted with $B$. 


\subsection{Assignment}
PHP supports two types of assignments, a regular value-assignment and a reference-assignment using the \texttt{\&} operator. 
Each assignment can be split up in three categories, variable-, array-write-, and array-append-assignments, depending on the target (left side of the operation). Examples of these six operations can be seen in program \ref{lst:assignments}.
\begin{program}
\begin{lstlisting}
<?php

$a = []; //Value assignment
$a[] = 1; //Array append assignment
$a[1] = 2; //Array write assignment

$b = &$a; //Value reference assignment
$c[] = &$a;//Array append reference assignment
$d[1] = &$a; //Array write reference assignment

\end{lstlisting}
\caption{Assignments}
\label{lst:assignments}
\end{program}
\subsection{Function calls}



\begin{description}
\item[$E(t)$] represent an expression $E$ with the result of its evaluation, stored in temporary variable $t$
\item[$Ve(L)$] ?
\item[$Re(L)$] ?
\item[$Ae(L)$] ?
\item[$start$] ?
\item[$nop$] ?
\item[$if(t)$] handle a condition stored in temporary variable $t$
\item[$bop_{\oplus}(t_l,t_r,t_{tar})$] a binary operation, $\oplus$, on $t_l$ and $t_r$ with the result stored in $t_{tar}$
\item[$uop_{\circ}(t_{val},t_{tar})$] an unary operation, $\circ$ on $t_{val}$ storing the result in $t_{tar}$
\item[$inc_{\circ}(h_{val},t_{tar})$] an $\circ$ (increment or decrement) operation. For pre- the values at locations in $L$ are in/decremented and the value stored in t, for post- the values at locations in $L$ are stored in t and the in/decremented
\item[$sop_{\oplus}(t_l,t_r,t_{tar})$] a binary operation, $\oplus$ on $t_l$ and $t_r$ which may only evaluate the first expression if the result is known without evaluating the second expression. The result is stored in $t_{tar}$
\item[$call_{fn}(L_1,\dots,t_n)$] a function call with parameters $t_1$ through $t_n$, this node have corresponding \emph{exit} and \emph{result} nodes that handle passing information to functions and passing the result back 
\item[$return_{call_{fn}}(h_{val})$] ? 
\item[$return_{call_{fn}}(t_{val})$] ? 
\item[$exit(L_1, \cdots, t_n)$] ?
\item[$result(t_{val})$] ? 
\item[$result(h_{val})$] ? 
\item[$const_r(c, t_{tar})$] ? 
\item[$array_i(t_{tar})$] initialize an array in the temporary variable $t_{tar}$
\item[$array_a(t_{val},t_{ar})$] append the value of $t_{val}$ to the array in $t_{ar}$
\item[$array_a(h_{var}, t_{val},t_{tar})$] ?
\item[$array_a(h_{var}, h_{val},t_{tar})$] ?
\item[$array_a(h_{var}, h_{tar})$] ?
\item[$array_w(t_{key},t_{val},t_{ar})$] write the value of $t_{val}$ to the index stored in $t_{key}$ in the array stored in $t_{ar}$
\item[$array_w(h_{var}, t_{key},t_{val},t_{tar})$] ? 
\item[$array_w(h_{var}, t_{key},h_{val},t_{tar})$] ? 
\item[$array_r(t_{ar},t_{key},t_{tar})$] read the index stored in $t_{key}$ from the array stored in $t_{ar}$ and store the result in $t_{tar}$
\item[$array_r(h_{var},t_{key},h_{tar})$] ? 
\item[$var_w(v,t_{val},t_{tar})$] write the value of variable $t_{val}$ to $v$ and store it at stack variable $t_{tar}$.
\item[$var_w(v,h_{val},t_{tar})$] ? 
\item[$var_r(v,t_{tar})$] read the variable $v$ into the temporary variable $t_{tar}$
\item[$var_r(v,h_{tar})$] ? 
\item[$global(v_1, v_2, \cdots, v_n)$] create new alias variables $v_1$, ..., $v_n$ in the local scope for each global counterpart.
\end{description}

\todo{Add missing signatures}
\todo{Examples and mention interesting cases.}
\todo{If its statically certain that the if expression is true or false, then the flow is limited}
% Define block styles
\todo{Write about $Re$}
 \todo{change to new nodes}

The below description uses the following shorthands for parts of the grammar:

\begin{verbatim}
<function>: F
<function-name>: f
<statement>: S
<block>: B
<expr>: E
<var-list>: VL
<var>: V
<statement-list>: SL
<expr-list>: EL
<empty-array-init>: EAI
<array-init>: AI
<array-init-entry>: AIE
<array-init-list>: AIL
<const>: C
<var-array-write>: VAW
<var-array-read>: VAR
array-read: E[E1]...[En]
\end{verbatim}

\begin{align*}
blocks(F) &= \{\texttt{function} f^{l_n}, end^{l_x} \} \cup blocks(B) \\
blocks(S SL) &= blocks(S) \cup blocks(SL) \\
blocks(\texttt{while} (E) S) &= blocks(E) \cup blocks(S) \\
blocks(\texttt{foreach} ( E ... ) S) &= blocks(E) \cup blocks(S) \\
blocks(\texttt{if} (E) B) &= blocks(E) \cup blocks(B) \\
blocks(\texttt{if} (E) S_1 else S_2) &= blocks(E) \cup blocks(S_1) \cup blocks(S_2) \\
blocks(;) &= \emptyset \\
blocks(E;) &= blocks(E) \\
blocks(\texttt{global VL;}) &= \{\texttt{global VL;}^l\} \\
blocks(B) &= blocks(SL) \\
blocks(E_1 \oplus E_2) &= \{E_1 \oplus E_2^l\} \cup blocks(E_1^{l_1}) \cup blocks(E_2^{l_2}) \\
blocks(!E)  &= \{ !E^l \} \cup blocks(E) \\
blocks((E)) &= \{ (E)^l \} \cup blocks(E) \\
blocks(\texttt{V++}) &= \{\texttt{V++}^l \} \\
blocks(\texttt{V-\,-}) &= \{\texttt{V-\,-}^l \} \\
blocks(f()) &= \{f()^{l_c,l_r} \} \\
blocks(f(EL) &= \{f(EL)^{l_c,l_r} \} \\
blocks(EAI) &= \{EAI^l \} \\
blocks(AI(AIL)) &= \{AI^l \} \cup blocks(AIL) \\
blocks(AIE AIL) &= blocks(AIE) \cup blocks(AIL) \\
blocks(E_1 => E_2) &= \{ E_1 => E_2^l \} \cup blocks(E_1) \cup blocks(E_2) \\
blocks(VAR) &= \{ VAR^l \} \cup blocks(E) \cup blocks(E_1) ... \cup blocks(E_n) \\
blocks(C) &= \{ C^l \} \\
blocks(VAW = E) &= \{ VAW = E^l \} \cup blocks(E) \\
blocks(VAW = \&VAR) &= \{ VAW = \&VAR^l \} \cup blocks(VAR) \\
blocks(V) &= \{ V^l \} 
\end{align*}

With the elementary blocks defined it is then possible to define flow between the blocks. The flow for the operation-expression is dependent on the type of the operator. Operators are divided into short-circuit operators (SCO) and non-short-circuit operators (nSCO). 
\todo{describe flow}
\end{comment}