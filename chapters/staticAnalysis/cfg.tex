\section{Control flow graph}
\label{sec:cfg}
\tikzstyle{subtree} = [rectangle, draw, fill=gray!20,  minimum width=4em, text badly centered, minimum height=3em]
\tikzstyle{node} = [draw, circle, minimum height=2em]
\tikzstyle{emptynode} = [draw, circle]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{entry} = [draw=none,fill=none]
\tikzstyle{exit} = [draw=none,fill=none]
\tikzstyle{dots} = [draw=none,fill=none]
\newcommand{\subt}[1]{\llbracket #1\rrbracket}

Parsing a P0 program $p : \syn{program}$ to an abstract syntax tree, the control flow graph can be constructed recursively. Most of the nodes take one or more arguments which are described in table \ref{tab:nodes}.

\begin{table}[htbp]
\centering
\begin{tabularx}{c|X}
 Symbol & Description \\\hline\hline
 $t \in \text{Temps}$ & A temporary variable name used to pass evaluated values between CFG nodes \\
 $h \in \text{HeapTemps}$ & A temporary heap variable name used to pass a set of heap locations between CFG nodes \\
 $c \in \text{Temps}\bigcup\text{HeapTemps}$ & Either of the above two types of variable names \\
 $\subt{S}$ & Sub graph for statement $S$ \\
 $\subt{E}(t)$ & Sub graph for expression $E$ with evaluation result stored in $t$ \\
 $\subt{R}(h)$ & Sub graph for reference expression $R$ with evaluated heap-location set stored in $h$ \\
 $\subt{V}(h)$ & Sub graph for a variable expression $V$ with evaluated heap-location set stored in $h$ \\
 $\subt{T}(c)$ & Sub graph for either an expression, a reference expression or a variable expression with $c$ being the corresponding $t$ or $h$ as described above
\end{tabularx}
\caption{Symbols used in the control flow graph}
\label{tab:nodes}
\end{table}


Here $h$ denotes variables of type HeapTemps, $t$ variables of type Temps, and $c$ variables of either type. Subgraphs are denoted by a grey rectangles with letters $\subt{S}$, $\subt{E}(t)$, $\subt{R}(h)$, $\subt{V}(h)$, and $\subt{T}(c)$ which denotes subgraph of statement $S$, expression $E$ with the resulting value stored in variable $t$, reference expression $R$ with resulting heap-location-set stored in $h$, variable expression $V$ with resulting heap-location-set stored in $h$, or either expression with the result stored in $c$ respectively. For a given argument, $c$, to the subgraph, the variable corresponds to the target variable, $c_{tar}$, in the subgraph. E.g. let  $E = \texttt{1+(2+3)}$ then the graph of $\subt{E}(t)$ is recursively constructed as in graph \ref{graph:exexpr}. Notice how the argument, $t$, passed to the graph is the third argument of the last $\mathit{bop}_+(\_)$ node.
\begin{definition}
\label{def:cfg}
A control-flow-graph $G = (V,E, s, t)$ where $V$ is a set of nodes, $E$ is a set of node pairs representing an edge between two nodes, $s\in V$ is a start node and $t\in V$ is an exit node. When illustrated as a graph, the entry node is marked with an ingoing edge with no origin and the exit node is marked with an outgoing edge with no target. E.g. in example graph \ref{graph:exexpr}, $s = \mathit{constRead}(1, t_1)$ and $t = \mathit{bop}_+(t_1, t_2, t)$.
\end{definition}

There are seventeen different nodes, all introduced below
\begin{description}
\item{$\mathit{start}$:} This node indicates the start of a program and is the first node of any program or function body. 
\item{$\mathit{bop_{\oplus}}(t_l,t_r, t_{tar})$, $\mathit{sop_{\oplus}}(t_l,t_r, t_{tar})$, $\mathit{uop_{\circ}}(t, t_{tar})$, $\mathit{inc_{\circ}}(h, t_{tar})$:} These nodes indicates binary, short-circuit-binary, uanry, and increment/decrement operations, respectively. The operations of the first three are all performed on temporary storage, while the forth is performed on the heap. The last argument, $t_{tar}$, indicates where the result of performing the operation should be stored. E.g. $\texttt{1+2}$ is a binary operation ($\mathit{bop}$) returning $\texttt{3}$, this value should be stored in temporary storage at $t_{tar}$. 
\item{$\mathit{if}(t)$:} This node has one incoming and two outgoing edges, representing the choice of one branch or the other, when evaluating $t$. 
\item{$\mathit{constRead}(c, t_{tar})$:} This node representing reading a constant into the temporary storage, at $t_{tar}$. The constant can be strings, booleans, null, ints etc.
\item{$\mathit{varRead}(\texttt{\$v}, c_{tar})$, $\mathit{varWrite}(\texttt{\$v}, c_{val}, t_{tar})$:} These nodes indicates reading from and writing to a variable, \texttt{\$v}, respectively. Depending on the context the target of the read and value of the write can either be a temporary or temporary heap storage. 
\item{$\mathit{arrayInit}(t_{tar})$:} This node represents initializing an empty array in the temporary storage, at $t_{tar}$.
\item{$\mathit{arrayAppend}(t_{val}, t_{ar})$, $\mathit{arrayAppend}(h_{var}, c_{val}, t_{tar})$, $\mathit{arrayAppend}(h_{var}, h_{tar})$:} With three different signatures, this node represents appending to an array, in temporary storage, in the heap, and in a read-context. Normally PHP will not allow appending without a value, but in this case, the reference of the appended entry is placed in temporary heap storage, and thus accessible for later modification. The $c_{val}$ variable in the second node indicates that both values and references can be appended to an array.
\item{$\mathit{arrayRead}(h_{ar}, t_{key}, c_{tar})$:} Reading from an array on the heap, with value key at $t_{key}$. The result can either be references to the entry or values at the given key, hence the $c_{tar}$ variable. 
\item{$\mathit{arrayWrite}(t_{val}, t_{ar})$, $\mathit{arrayWrite}(h_{ar}, c_{val}, t_{tar})$:} Writing to an array in temporary storage or in the heap, respectively. Just as append, the value written can be either references or a value, hence the $c_{val}$ variable.
\item{$\mathit{call}_{\mathit{fn}}(c_1, \cdots, c_n)$, $\mathit{exit}(c_1, \cdots, c_n)$, $\mathit{result}_{c}(c_{tar})$:} Calling a function is performed with the $\mathit{call}$ node. This holds the name, $\mathit{fn}$, of the function being called (which can always be resolved). For every call node, $c$, there is a single result node, $\mathit{result}_c$. This restores the calling context and handles passing of the result. The node immediately before the result node is an $\mathit{exit}$ node, which is unique to and last node of the function being called. This node holds variable names pointing to the possible values returned by the function. 
\item{$nop$:} This node does nothing and is only there for structural purposes. It is in the control-flow-graphs denoted as a small node with no label.
\end{description}
\todo{Describe all node-arguments}
\begin{graph}
\centering
\begin{adjustbox}{max size={1\textwidth}{.25\textheight}, margin = 10pt}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
	\node [entry] (en) {};
 	\node [subtree, right of =en] (t1){\scriptsize $\subt{\texttt{1+(2+3)}}(t)$};
	\node [exit, right of=t1] (ex) {};
    % Draw edges
    \path[line] (en) -> (t1);
    \path[line] (t1) ->(ex);

\end{tikzpicture}\end{adjustbox}

\begin{adjustbox}{max size={1\textwidth}{.25\textheight}, margin = 10pt}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
	\node [entry] (en) {};
 	\node [node, right of=en, label={270:$\mathit{constRead}(\texttt{1},t_1)$}] (c1) {};
 	\node [subtree, right of =c1] (t1){$\subt{\texttt{2+3}}(t_2)$};
 	\node [node, right of=t1, label={270:$\mathit{bop}_+(t_1,t_2, t)$}] (bop1) {};
	\node [exit, right of=bop1] (ex) {};
    % Draw edges
    \path[line] (en) -> (c1);
    \path[line] (c1) -> (t1);
    \path[line] (t1) -> (bop1);
     \path[line] (bop1) -> (ex);

\end{tikzpicture}\end{adjustbox}
\begin{adjustbox}{max size={1\textwidth}{.25\textheight}, margin = 10pt}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
	\node [entry] (en) {};
 	\node [node, right of=en, label={270:$\mathit{constRead}(\texttt{1},t_1)$}] (c1) {};
 	\node [node, right of=c1, label={90:$\mathit{constRead}(\texttt{2},t_3)$}] (c2) {};
 	\node [node, right of=c2, label={270:$\mathit{constRead}(\texttt{3},t_4)$}] (c3) {};
 	\node [node, right of=c3, label={90:$\mathit{bop}_+(t_3,t_4, t_2)$}] (bop1) {};
 	\node [node, right of=bop1, label={270:$\mathit{bop}_+(t_1,t_2, t)$}] (bop2) {};
	\node [exit, right of=bop2] (ex) {};
    % Draw edges
    \path[line] (en) -> (c1);
    \path[line] (c1) -> (c2);
    \path[line] (c2) -> (c3);
    \path[line] (c3) -> (bop1);
     \path[line] (bop1) -> (bop2);
    \path[line] (bop2) -> (ex);

\end{tikzpicture}\end{adjustbox}

\caption{Recursively constructing graph $\subt{\texttt{1+(2+3)}}(t)$}
\label{graph:exexpr}
\end{graph}

The control-flow graph created from $p$ starts with a $\mathit{start}$ node followed by the control-flow graphs for each statement in $p$, connected edges from exit to entry nodes, in the order of appearance. 

For each function definition encountered a separate graph is created, which may later be referenced. This graph starts with a $\mathit{start}$ node and ends with an $\mathit{exit}$ node, between these are the graph corresponding to the function body. The arguments of the exit node are the temporary variables created by the return statements. 

\subsection{Statements}
Let $s : \syn{statement}$ be a statement, then there are nine different graphs, one for each case in the grammar \ref{gramm:p0}. The first four, for $s = $ \texttt{while($E$) $S$}, $s = $ \texttt{for($E_1$;$ E_2$;$E_3$) $S$}, $s = $ \texttt{if($E$) $S$}, and $s = $ \texttt{if($E$) $S_1$ else $S_2$} statements, are depicted as graph \ref{graph:flowwhile}, \ref{graph:flowfor}, \ref{graph:flowif}, and \ref{graph:flowifelse} respectively.


\begin{graph}
\captionsetup{justification=centering}
\hspace*{\fill}
\subcaptionbox{\texttt{while}-statement\label{graph:flowwhile}}{\begin{adjustbox}{max size={.25\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree, below of=en] (e1) {$\subt{E}(t)$};
    \node [node, below of=e1, label={0:$\mathit{if}(t)$}] (if) {};
    \node [subtree, below of=if ] (s1) {$\subt{S}$};
    \node [emptynode, below of=s1 ] (end) {};
    \node [exit, below of=end] (ex) {};

    % Draw edges
    \path[line] (en) -> (e1);
    \path [line] (e1) -> (if);
    \path [line] (if) -> (s1);
    \path [line] (if) -- (-2, -4) |- (end); 
    \path [line] (s1) -- (2, -6) |- (e1); 
    \path [line] (end) -> (ex);
\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{\texttt{for}-statement\label{graph:flowfor}}{\begin{adjustbox}{max size={.25\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    
    \node [entry] (en) {};
    \node [subtree, below of=en] (e1) {$\subt{E_1}(\_)$};
    \node [subtree, below of=e1] (e2) {$\subt{E_2}(t)$};
    \node [node, below of=e2, label={135:$\mathit{if}(t)$}] (if) {};
    \node [subtree, below left of=if] (s) {$\subt{S}$};
    \node [subtree, below right of=if] (e3) {$\subt{E_3}(\_)$};
    \node [emptynode, below right of=s] (end) {};
    \node [exit, below of=end] (ex) {};
    
    % Draw edges
    \path [line] (en) -> (e1);
    \path [line] (e1) -> (e2);
    \path [line] (e2) -> (if);
    \path [line] (if) -> (s);
    \path [line] (s) -> (e3);
%    \path [line] (e3) -> (end);
    \path [line] (end) -> (ex);
    \path [line] (e3) |- (e2);
    \path [line] (if) -- (-3, -6) |- (end);
\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{\texttt{if}-statement\label{graph:flowif}}{\begin{adjustbox}{max size={.25\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    
    \node [entry] (en) {};
    \node [subtree, below of=en] (e1) {$\subt{E}(t)$};
    \node [node, below of=e1, label={45:$\mathit{if}(t)$}] (if) {};
    \node [subtree, below of=if] (s1) {$\subt{S}$};
    \node [emptynode, below of=s1](end) {};
    \node [exit, below of=end] (ex) {};
    
    % Draw edges
    \path [line] (en) -> (e1);
    \path [line] (e1) -> (if);
    \path [line] (if) -> (s1);
    \path [line] (s1) -> (end);
    \path [line] (if) -- (2,-4) |-  (end);
    \path [line] (end) -> (ex);
\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{\texttt{if-else}-statement\label{graph:flowifelse}}{\begin{adjustbox}{max size={.25\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree,below of=en] (e1) {$\subt{E}(t)$};
    \node [node, below of=e1, label={35:$\mathit{if}(t)$}] (if) {};
    \node [subtree, below left of=if] (s1) {$\subt{S_1}$};
    \node [subtree, below right of=if] (s2) {$\subt{S_2}$};
    \node [emptynode, below right of=s1](end) {};
    \node [exit, below of=end] (ex) {};
    % Draw edges
    \path[line] (en) -> (e1);
    \path [line] (e1) -> (if);
    \path [line] (if) -> (s1);
    \path [line] (if) -> (s2);
    \path [line] (s1) -> (end);
    \path [line] (s2) -> (end);
    \path [line] (end) -> (ex);
\end{tikzpicture}\end{adjustbox}}
\hspace*{\fill}
\end{graph}

%For $s =$ \texttt{global $v_1,\cdots, v_n$} the graph is containing a single, $global$, node which takes the variable names $v_1,\cdots v_n$ as argument. 
Return-statements, $s =$ \texttt{return $T$} have three different graphs. If the return statement is empty, i.e. does not contain an expression, then this is equivalent of returning \texttt{null}, this case yields the graph in \ref{graph:floweret}. If $T : \syn{rexpr}$ and the function is a reference function, i.e. the function signature has an ampersand before the function name (see program \ref{lst:retref}), then the references is returned (graph \ref{graph:flowret} where $c : \text{HeapTemps}$). If this is not the case, (see program \ref{lst:retnoref}), assuming the program is a valid P0 program, then it is fair to assume that $T$ can be parsed as an expression, since it cannot be an array-append operation. If it was an array append operation, then the program wouldn't be a valid PHP program and thus not a valid P0 program (see section \ref{sec:langsubset}). Assuming that the $T : \syn{expr}$ the graphs for a return statement should evaluate $T$ and return the result, this is the case in graph \ref{graph:flowret} with $c : \text{Temps}$.  For all graphs, the exit-node is the unique exit-node of the function.

\begin{program}
 \begin{subfigure}[b]{.45\linewidth}
	\begin{lstlisting} 
function normRet(){
	$a++;	
	return $a;
}
	\end{lstlisting}
    \caption{Normal return-statement}
    \label{lst:retnoref}
  \end{subfigure}\hfill%
 \begin{subfigure}[b]{.45\linewidth}
	\begin{lstlisting} 
function &refRet(&$a){
	return $a[];
}

	\end{lstlisting}
    \caption{Reference return-statement}
    \label{lst:retref}
  \end{subfigure}

\caption{Return-statement examples}
\label{lst:return-statements}
\end{program}

\begin{graph}
\captionsetup{justification=centering}
\hspace*{\fill}
\subcaptionbox{\texttt{return}-statement\label{graph:floweret}}{\begin{adjustbox}{max size={.3\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [node, below of=en, label={45:$\mathit{constRead}(\texttt{null}, t_{tar})$}] (const) {};
    \node [node, below of=const, label={45:$\mathit{exit}(\cdots, t_{tar}, \cdots)$}] (exitn) {};
    \node [emptynode, below of=exitn ] (end) {};
    \node [exit, below of=end] (ex) {};
      % Draw edges
    \path[line] (en) -> (const);
    \path[line] (const) -> (exitn);
    \path[line] (end) -> (ex);
    
\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{\texttt{return}-expression-statement\label{graph:flowret}}{\begin{adjustbox}{max size={.3\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree, below of=en] (exp) {$\subt{T}(c)$};
    \node [node, below of=exp, label={45:$\mathit{exit}(\cdots, c, \cdots)$}] (exitn) {};
    \node [emptynode, below of=exitn ] (end) {};
    \node [exit, below of=end] (ex) {};
    % Draw edges
    \path[line] (en) -> (exp);
    \path[line] (exp) -> (exitn);
    \path[line] (end) -> (ex);
    
\end{tikzpicture}\end{adjustbox}}
\hspace*{\fill}
\end{graph}

The remaining four graphs are the empty graph, the graph of the expression statement, the graph of \texttt{global} statement, and the graph of the block statement which are all straight-foward.


\subsection{Expressions}

Let $e : \syn{expr}$ then, by ignoring the trivial parenthesized expression case, viewing the four increment/decrement operations as one, and the two array-initialization operations as one, the expression can be on nine different forms. For $e = E_l \oplus E_r$ the graph depends on the operation. If the operation is a short-circuit operation, logical \texttt{\&\&} or \texttt{||}, then the graph is as \ref{graph:flowsop} because only one branch may be required to be evaluated. If the operation is not a short-circuit operation then the graph becomes as \ref{graph:flowbop}, because both expressions must be evaluated. In both cases the operations are performed on, and saved in, the temporary storage. The unary operation, $e = \circ E$ is similar to the previous case with a graph as \ref{graph:flowuop}. A separate graph for unary post/pre increment/decrement operations are necessary because of the performed update on the heap location. This is the reason for the operations not being performed on the temporary storage, but instead on heap-locations directly. The result of the operation is stored in the temporary storage. Figure \ref{graph:flowinc} illustrates the corresponding flow graph.
\begin{graph}
\captionsetup{justification=centering}
\hspace*{\fill}
\subcaptionbox{Short-circuit binary operation\label{graph:flowsop}}{\begin{adjustbox}{max size={.24\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree, below of=en] (e1) {$\subt{E_l}(t_l)$};
    \node [node, below of=e1, label={0:$\mathit{if}(t_l)$}] (if) {};
    \node [subtree, below of=if] (e2) {$\subt{E_r}(t_r)$};
    \node [node, below of=e2, label={0:$\mathit{sop}_\oplus(t_l,t_r,t_{tar})$}] (sop) {};
    \node [exit, below of=sop] (ex) {};

    % Draw edges
    \path [line] (en) -> (e1);
    \path [line] (e1) -> (if);
    \path [line] (if) -> (e2);
    \path [line] (e2) -> (sop);
    \path [line] (if) -- (-2, -4) |- (sop);
    \path [line] (sop) -> (ex);
\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{Binary operation\label{graph:flowbop}}{\begin{adjustbox}{max size={.24\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree, below of=en] (e1) {$\subt{E_l}(t_l)$};
    \node [subtree, below of=e1] (e2) {$\subt{E_r}(t_r)$};
    \node [node, below of=e2, label={0:$\mathit{bop}_\oplus(t_l,t_r,t_{tar})$}] (bop) {};
    \node [exit, below of=bop] (ex) {};
    
    % Draw edges
    \path [line] (en) -> (e1);
    \path [line] (e1) -> (e2);
    \path [line] (e2) -> (bop);
    \path [line] (bop) -> (ex);
    
\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{Unary operation\label{graph:flowuop}}{\begin{adjustbox}{max size={.24\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree, below of=en] (e) {$\subt{E}(t_{val})$};
    \node [node, below of=e, label={0:$\mathit{uop}_\circ(t_{val},t_{tar})$}] (uop) {};
    \node [exit, below of=uop] (ex) {};

    % Draw edges
    \path [line] (en) -> (e);
    \path [line] (e) -> (uop);
    \path [line] (uop) -> (ex);
\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{Post/pre increment/decrement opreation\label{graph:flowinc}}{\begin{adjustbox}{max size={.24\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree, below of=en] (e) {$\subt{V}(h_{val})$};
    \node [node, below of=e, label={0:$\mathit{inc}_\circ(h_{val},t_{tar})$}] (inc) {};
    \node [exit, below of=inc] (ex) {};

    % Draw edges
    \path [line] (en) -> (e);
    \path [line] (e) -> (inc);
    \path [line] (inc) -> (ex);
\end{tikzpicture}\end{adjustbox}}%
\hspace*{\fill}
\end{graph}

For a variable read, $e = \texttt{\$v}$ for some variable \texttt{\$v}, or a constant read, e.g. $e = \texttt{"foo"}$, the graph is a single $\mathit{varRead}(\texttt{\$v}, t_{tar})$ or $\mathit{constRead}(\texttt{"foo"}, t_{tar})$ node respectively. For an array read expression, $e = E_{ar}\texttt[E_{key}\texttt{]}$, the sub array expression, $E_{ar}$, should be evaluated before the key expression, $E_{key}$, and the graph then becomes like graph \ref{graph:flowaread}, where $T$ is the graph corresponding to $E_{ar}$ and $c_{ar}, c_{tar} : \text{Temps}$. If the expression is an array initialization, $e = \texttt{[}\cdots, E_1, \cdots, E_2\texttt{=>}E_3\texttt{]}$, then an array is first initialized in temporary storage after the entries are either appended or written to the array. Hence graph \ref{graph:flowai}.
\begin{graph}
\captionsetup{justification=centering}
\hspace*{\fill}
\subcaptionbox{Array read \label{graph:flowaread}}{\begin{adjustbox}{max size={.3\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree, below of=en] (e1) {$\subt{T}(c_{ar})$};
    \node [subtree, below of=e1] (e2) {$\subt{E_{key}}(t_{key})$};
    \node [node, below of=e2, label={0:$\mathit{arrayRead}(c_{ar},t_{key},c_{tar})$}] (rd) {};
    \node [exit, below of=rd] (ex) {};
    
    % Draw edges
    \path [line] (en) -> (e1);
    \path [line] (e1) -> (e2);
    \path [line] (e2) -> (rd);
    \path [line] (rd) -> (ex);
\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{Array initialize\label{graph:flowai}}{\begin{adjustbox}{max size={.3\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [node, below of=en, label={0:$\mathit{arrayInit}(t_{ar})$}] (ai) {};
    \node [dots, left of=ai] (dots1) {$\vdots$};
    \node [subtree, below of=dots1] (e1) {$\subt{E_1}(t_1)$};
    \node [node, right of=e1, label={45:$\mathit{arrayAppend}(t_1, t_{ar})$}] (app) {};
	\node [dots, right of=app] (dots2) {$\vdots$};
    \node [subtree, below of=dots2] (e2) {$\subt{E_2}(t_2)$};
    \node [subtree, left of=e2] (e3) {$\subt{E_3}(t_2)$};
	\node [node, left of=e3, label={-85:$\mathit{arrayWrite}(t_2, t_3, t_{ar})$}] (aw) {};
	\node [exit, below of=aw] (ex) {};

    % Draw edges
    \path [line] (en) -> (ai);
    \path [line] (ai) -> (dots1);
    \path [line] (dots1) -> (e1);
    \path [line] (e1) -> (app);
    \path[line] (app) -> (dots2);
    \path[line] (dots2) -> (e2);
    \path[line] (e2) -> (e3);
    \path[line] (e3) -> (aw);
        \path[line] (aw) -> (ex);



\end{tikzpicture}\end{adjustbox}}
\hspace*{\fill}
\end{graph}

For function calls, $e = \mathit{fn}\texttt{(}T_1,\cdots, T_n\texttt{)}$, the result variable is a temporary variable, $c_{tar}:\text{Temps}$, the arguments are either an expression, $T_i : \syn{expr}$ and $c_i : \text{Temps}$, or an reference expression, $T_i : \syn{rexpr}$ and $c_i : \text{HeapTemps}$, depending on the signature of $\mathit{fn}$. If the argument is pass-by-reference i.e. the variable, $v_i$ is denoted with a \texttt{\&} in the signature, then the expression must be a reference expression, if not, then the argument is an expression. This follows from the program being a valid P0 program. The function graph will be as graph \ref{graph:flowcall}, where the start node, exit node, and function body are the unique nodes of the $\mathit{fn}$ function i.e. they are not copied. This ensures that the graph is finite, but multiple, say $n$, calls to the same function will yield a graph with $n$ edges to the start node and from the exit node. Notice the dashed line going directly from the call node to the return node. This indicates that the call node may pass information directly to the return node, typically information regarding the local context before calling $\mathit{fn}$.

\begin{graph}
\centering
\captionsetup{justification=centering}
\begin{adjustbox}{max size={.3\textwidth}{.40\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree, below of=en] (e1) {$\subt{T_1}(c_1)$};
    \node [dots, below of=e1] (dots) {$\vdots$};
    \node [subtree, below of=dots] (em) {$\subt{T_n}(c_n)$};
    \node [node, below of=em] [label={-90:$call_{\mathit{fn}}(c_1,\cdots,c_n)$}] (call) {};
    \node [node, right of=call, label={$\mathit{start}$}] (entry) {};
    \node [subtree, below of=entry] (sl) {$B$};
    \node [node, below of=sl, label={-90:$\mathit{exit}(t)$}] (exit) {};
    \node [node, left of=exit, label={$\mathit{result}_{call_{\mathit{fn}}}(c_{tar})$}] (result) {};
    \node [exit, below of=result] (ex) {};

    % Draw edges
    \path [line] (en) -> (e1);
    \path [line] (e1) -> (dots);
    \path [line] (dots) -> (em);
    \path [line] (em) -> (call);
    \path [line] (call) -> (entry);
    \path [line] (entry) -> (sl);
    \path [line] (sl) -> (exit);
    \path [line] (exit) -> (result);
    \path [line] (result) -> (ex);
    \draw [dashed, ->] (call) -- (-2, -8) |- (result);
\end{tikzpicture}\end{adjustbox}
\caption{Function call \label{graph:flowcall}}
\end{graph}

Finally the expression can be an assignment. There are two types of assignments, a regular value-assignment and a reference-assignment, using the \texttt{\&} operator. Each assignment can be split up in three categories, variable-, array-write-, and array-append-assignments, depending on the target (left side of the operation). Examples of these six operations can be seen in program \ref{lst:assignments}. Due to the distinction between temporary storage of values and heap-location-sets, these six cases must be handled individually. For value array write ($e = R\texttt{[$E_{key}$]=} E_{val}$), array append ($e = R\texttt{[]=} E_{val}$), and variable write ($e = \texttt{\$v=} E_{val}$), the graphs are as \ref{graph:flowawrite}, \ref{graph:flowaappend}, and \ref{fig:vwrite} respectively, where $T$ is the subgraph of the value expression $E_{val} : \syn{expr}$ and $c_{val} : \text{Temps}$ is the temporary variable holding the result. The reference assignments,  $e = R\texttt{[$e_{key}$]=\&} R_{val}$, $e = r\texttt{[]=\&} R_{val}$, and $e = \texttt{\$v=\&} R_{val}$, are similar, but with $T$ being the subgraph of the reference expression, $R_{val} : \syn{rexpr}$ and $c_{val} : \text{HeapTemp}$ the heap temporary variable holding the heap locations of the value.
\begin{graph}
\captionsetup{justification=centering}
\hspace*{\fill}
\subcaptionbox{Array write\label{graph:flowawrite}}{\begin{adjustbox}{max size={.24\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree, below of=en] (ve) {$\subt{R}(h_{var})$};
    \node [subtree, below of=ve] (e1) {$\subt{E}(t_{key})$};
    \node [subtree, below of=e1] (e2) {$\subt{T}(c_{val})$};
    \node [node, below of=e2, label={0:$\mathit{arrayWrite}(h_{var}, t_{key},c_{val},t_{tar})$}] (rd) {};
    \node [exit, below of=rd] (ex) {};
    
    % Draw edges
    \path [line] (en) -> (ve);
    \path [line] (ve) -> (e1);
    \path [line] (e1) -> (e2);
    \path [line] (e2) -> (rd);
    \path [line] (rd) -> (ex);

\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{Array append \label{graph:flowaappend}}{\begin{adjustbox}{max size={.24\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree, below of=en] (ve) {$\subt{R}(h_{var})$};
    \node [subtree, below of=ve] (e1) {$\subt{T}(c_{val})$};
    \node [node, below of=e1, label={0:$\mathit{arrayAppend}(h_{var}, c_{val},t_{tar})$}] (rd) {};
    \node [exit, below of=rd] (ex) {};
    
    % Draw edges
    \path [line] (en) -> (ve);
    \path [line] (ve) -> (e1);
    \path [line] (e1) -> (rd);
    \path [line] (rd) -> (ex);

\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{Array append without write\label{graph:flowaappend2}}{\begin{adjustbox}{max size={.24\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree, below of=en] (ve) {$\subt{R}(h_{var})$};
    \node [node, below of=ve, label={0:$\mathit{arrayAppend}(h_{var},h_{tar})$}] (rd) {};
    \node [exit, below of=rd] (ex) {};
    
    % Draw edges
    \path [line] (en) -> (ve);
    \path [line] (ve) -> (rd);
    \path [line] (rd) -> (ex);

\end{tikzpicture}\end{adjustbox}}\hfill%
\subcaptionbox{Variable write\label{fig:vwrite}}{\begin{adjustbox}{max size={.24\textwidth}{.25\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [entry] (en) {};
    \node [subtree, below of=en] (e2) {$\subt{T}(c_{val})$};
    \node [node, below of=e2, label={0:$\mathit{varWrite}(\texttt{\$$$v},c_{val},t_{tar})$}] (ass) {};
    \node [exit, below of=ass] (ex) {};
    
    % Draw edges
    \path [line] (en) -> (e2);
    \path [line] (e2) -> (ass);
    \path [line] (ass) -> (ex);
\end{tikzpicture}\end{adjustbox}}
\hspace*{\fill}
\end{graph}
\begin{program}
\begin{lstlisting}
<?php

$a = []; //Value assignment
$a[] = 1; //Array append assignment
$a[1] = 2; //Array write assignment

$b = &$a; //Value reference assignment
$c[] = &$a;//Array append reference assignment
$d[1] = &$a; //Array write reference assignment

\end{lstlisting}
\caption{Assignments}
\label{lst:assignments}
\end{program}

\subsection{Reference and variable expressions}
Since PHP supports nested assignments e.g. \texttt{\$a[]['foo']  = \&func()[]}, deciding which location to update is performed recursively. The graph of this assignment is illustrated as graph \ref{graph:exassign}. Here the locations of variable \texttt{\$a} is stored in variable $h_{var'}$. Then a new location, $l$, is appended to the array values of the locations in $h_{var'}$, and $h_{var} = \{l\}$. Now the expression of the index is resolved and stored in $t_{key}$, and the locations of the right side is resolved in $h_{val}$. Finally the locations in $h_{val}$ are written to the array at $h_{var}$, i.e. $l$, with the key of $t_{key}$. 

\begin{graph}
\centering
\begin{adjustbox}{max size={.33\textwidth}{.33\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
	\node [entry] (en) {};
	\node [subtree, below of =en](t1) {	 $\subt{\texttt{\$$$a[]}}(h_{var})$};
	\node [subtree, below of =t1](t2) {$\subt{\texttt{'foo'}}(t_{key})$};
	\node [subtree, below of =t2](t3) { $\subt{\texttt{func()[]}}(h_{val})$};
	\node [node, below of =t3, label={-45:$\mathit{arrayWrite}(h_{var}, t_{key}, h_{val}, t)$}] (ass) {};
	\node [exit, below of=ass] (ex) {};
    % Draw edges
    \path [line] (en) -> (t1);
    \path [line] (t1) -> (t2);
    \path [line] (t2) -> (t3);
    \path [line] (t3) -> (ass);
    \path [line] (ass) -> (ex);

\end{tikzpicture}\end{adjustbox}
\begin{adjustbox}{max size={.33\textwidth}{.33\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
	\node [entry] (en) {};
	\node [subtree, below of =en](t1) {	 $\subt{\texttt{\$$$a}}(h_{var'})$};
	\node [node, below of = t1, label={-45:$\mathit{arrayAppend}(h_{var'}, h_{var})$}] (aa) {};
	\node [node, below of = aa, label={-45:$\mathit{constRead}(\texttt{'foo'}, t_{key})$}] (cr) {};		
	\node [subtree, below of =cr](t3) { $\subt{\texttt{func()}}(h_{val'})$};
	\node [node, below of = t3, label={-45:$\mathit{arrayAppend}(h_{val'}, h_{val})$}] (aa2) {};
	\node [node, below of =aa2, label={-45:$\mathit{arrayWrite}(h_{var}, t_{key}, h_{val}, t)$}] (ass) {};
	\node [exit, below of=ass] (ex) {};
    % Draw edges
    \path [line] (en) -> (t1);
    \path [line] (t1) -> (aa);
    \path [line] (aa) -> (cr);
    \path [line] (cr) -> (t3);
    \path [line] (t3) -> (aa2);
    \path [line] (aa2) -> (ass);
    \path [line] (ass) -> (ex);

\end{tikzpicture}\end{adjustbox}
\begin{adjustbox}{max size={.33\textwidth}{.33\textheight}}\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
	\node [entry] (en) {};
	\node [node, below of =en, label = {-45: $\mathit{varRead}(\texttt{\$$$a}, h_{var'})$}](t1) {};
	\node [node, below of = t1, label={-45:$\mathit{arrayAppend}(h_{var'}, h_{var})$}] (aa) {};
	\node [node, below of = aa, label={-45:$\mathit{constRead}(\texttt{'foo'}, t_{key})$}] (cr) {};		
	\node [node, below of =cr, label={-45:$call_{\texttt{func}}()$}](call) {};
	\node [node, below of =call, label={-45:$result_{call_{\texttt{func}}()}(h_{val'})$}](t3) {};
	\node [entry, right of =call] (fn) {};
	\node [node, below of = t3, label={-45:$\mathit{arrayAppend}(h_{val'}, h_{val})$}] (aa2) {};
	\node [entry, right of =t3] (fex) {};
	\node [node, below of =aa2, label={-45:$\mathit{arrayWrite}(h_{var}, t_{key}, h_{val}, t)$}] (ass) {};
	\node [exit, below of=ass] (ex) {};
    % Draw edges
    \path [line] (en) -> (t1);
    \path [line] (t1) -> (aa);
    \path [line] (aa) -> (cr);
    \path [line] (cr) -> (call);
    \path [line] (call) -> (fn);
    \draw [dashed, ->] (call) -- (t3);
    \path [line] (t3) -> (aa2);
    \path [line] (fex) -> (t3);
    \path [line] (aa2) -> (ass);
    \path [line] (ass) -> (ex);

\end{tikzpicture}\end{adjustbox}
\caption{Creating graph of expression $\subt{\texttt{\$a[]['foo']  = \&func()[]}}(t)$}
\label{graph:exassign}
\end{graph}

The subtrees which takes a $h : \text{HeapTemp}$ variable are called reference- and variable-expressions. Where the only difference between the two is that reference expressions may contain function references. As seen in the previous example they resolve heap-locations rather than values. For $r = \mathit{fn} \texttt{(}c_1, \cdots, c_n\texttt{)}$ the graphs corresponds to graph \ref{graph:flowcall}, with heap-locations as result, i.e. $c_{tar} : \text{HeapTemps}$. For the variable read, $r = \texttt{\$v}$, the graphs is a single $\mathit{varRead}(\texttt{\$v}, h_{tar})$ node. When the expression is an array-read, $r= R_{ar}[E_{key}]$, the graph corresponds to that of \ref{graph:flowaread} with $c_{ar},c_{tar} : \text{HeapTemps}$ and $T$ being the graph of $R_{ar}$. Finally for the append operation, $r = R_{ar}[]$, the graphs corresponds that of graph \ref{graph:flowaappend2}.