PHP (PHP: Hypertext Preprocessor) was created by Rasmus Lerdorf in 1995. As one of the first dedicated web development server-side languages it has become widely popular over the past 20 years. A survey\citeA{w3techs} shows that 82\% of websites use PHP, including some major websites, such as Facebook, which consequently has created their own gradual typed dialect of the language, called Hack, and HHVM (Hip Hop Virtual Machine), in order to deal with scalability and a enormous code base. The apparent simplicity, availability of the language, and cheap hosting solutions,  also enables creation of small websites relatively fast requiring no knowledge of types, concurrency, or objects from the programmer. It is no wonder why PHP, as it is the case for many other programmers, was the first programming language learned by the authors of this thesis.

\section{Program structure}
With the introduction of an object model with PHP 5 in 2005 followed a trend to organize PHP programs in an object oriented manner. 

For better organization of code, in 2009, namespaces were introduced (PHP 5.3) and the PHP Framework Interoperability Group, which aims to formulate standards on autoloading, coding style, logging, etc. was created. \todo{ref}. Utilizing these tools and standards, many modern frameworks are managing dependencies to other frameworks and libraries through package managers such as Composer \todo{ref}. Normally these dependencies are hosted open-source on GitHub, made available for composer on packagist. Composer also handles autoloading of classes, which in practice removes the task of manually loading PHP files using the \texttt{include "file.php";} or \texttt{require "file.php";} statement. 

These statements allows dynamically loading of dependencies, by taking an expression as argument, and resolving these statically has been subject for some research \todo{ref}. With autoloading and a proper program structure (as advocated by PHP-FIG) resolving dependencies statically becomes trivial.

With increasing complexity follows a need for quality assurance and testing. PHPUnit is a framework, written in PHP and available via. composer, that facilitates unit-testing. This framework is widely used and e.g. supports testing with databases and browser output through selenium integration. PHPUnit is also used for generating coverage information for code-analysers, such as code climate, and is natively supported, as a metric of quality, by continuous integration tools, such as travis CI. \todo{ref}. 

Travis CI is an online service, free for open-source projects, just as GitHub and Code Climate. It observers GitHub repositories and runs an advanced check on every new committed version, emulating multiple different deployment environments wrt. operating system, PHP interpreter version, web-server, etc. Emulating different environments locally can be done with vagrant which lowers development environment setup time by automating the process, making it possible for developers develop to a production environment.


\section{Language features}
PHP is a ever-changing language, with a new syntax and language features being introduced in every version. Features such as Objects, introduced and modified throughout PHP 5, anonymous functions, introduced in PHP 5.3, variadic functions, introduced in PHP 5.6, etc. Furthermore PHP supports a large number of alias features, i.e. features that semantically are the same, but has different syntax, e.g. array initialization can be written as \texttt{array($\cdots$)} or \texttt{[$\cdots$]}, boolean operators can be written as \texttt{\&\&}, \texttt{||} or \texttt{AND}, \texttt{OR}, array access can be denoted with brackets, \texttt{\$a['key']}, or curly-brackets \texttt{\$a\{'key'\}}, etc. In the rest of this section follows the description of some of the language features that has proven interesting when designing our analysis.

\subsection{Arrays in PHP}
The language construct \texttt{array} in PHP is an ordered map. Since \emph{keys} of these ordered maps can be either integer, string or a combination and \emph{values} can be any combination of types, it is possible to use arrays as many different collection types e.g. maps, lists, queues, stacks, trees, dictionaries and probably any other collection-like type that exists. 

Arrays can be multidimensional, by containing other arrays, or circular, by containing references to itself. They need not be initialized explicitly, but can be created by performing an array write, e.g. \texttt{\$a['foo'] = 42;}, or append, e.g. \texttt{\$a[] = 42;}, on an uninitialized variable or a variable containing \texttt{null}, which is practically the same.

\subsection{Scoping}
\label{sec:backg_scoping}

The variable scoping of PHP is rather simple; there is a unique global variable scope, which is the scope of the statements not part of any function body, a static variable scope for each function, holding static variables, and a scope for each function call. Variables declared in a scope is generally not directly accessible by other scopes. E.g. in order to access a variable defined in the global scope, from the scope of a function body, the \texttt{global} statement can be used to create a local alias variable pointing of the global variable. Similarly the static scope can be access with a \texttt{static} statement. All blocs share the scope of their parent.

The only variables directly accessible in both function and global scope, are the \emph{super-globals}. They are variables, containing arrays, including \texttt{\$\_POST}, \texttt{\$\_GET}, \texttt{\$\_REQUEST} and \texttt{\$\_COOKIE} for fetching data from HTTP POST requests, HTTP GET requests, HTTP POST and GET requests, and cookies respectively, \texttt{\$\_SERVER} and \texttt{\$\_ENV} for accessing server settings and environment variables, and a few others. Program \ref{lst:superglobals} shows an example of using \emph{superglobals}.
\todo{Other super-globals}
\begin{program}
\begin{lstlisting}
session_start();
$username = "";

function setUser($ID, $name) {
    global $username;
    $_SESSION["ID"] = $ID;
    $username = $name;
}

setUser(1, "Admin");

echo "Hello $username $_SESSION['ID']"; // Result: Hello Admin 1
\end{lstlisting}
\caption{Global variables used in function scope}
\label{lst:superglobals}
\end{program}

While the previous superglobals were defined by external conditions, such as requests or server settings, the variable \texttt{\$GLOBALS} is an array modeling the global scope. Reading, modifying, and adding entries in this array are equivalent to reading, modifying, and initializing variables in the global scope, and can thus be used to access global variables in function scope without using the \texttt{global} keyword.


\subsection{References}
\label{sec:backg_references}
Many languages have a notion of pointers and provides the ability for variables to be a pointer to some value. In PHP the concept of references can easily be confused with pointers, however references are not pointers. Variables names and their content is treated as different things in PHP, meaning that variable names are in fact just names for a specific content. Making a reference in PHP corresponds to giving the same content another name. Assigning a variable that is already a reference as a reference of another variable will remove the binding to the original content and bind the variable to the new content. The PHP concept of references also mean that it is not possible to change a reference by a reference as shown in program \ref{lst:reference-reference}.

\begin{program}
\begin{lstlisting}
$hello = "world";
$hello2 = "stupid";

function change(&$input) {
    $input = &$GLOBALS["hello2"];
    $input = "awesome";
}

change($hello);
// Result: $hello2 = "awesome" and $hello remains unchanged
\end{lstlisting}
\caption{Overwriting references}
\label{lst:reference-reference}
\end{program}

Knowing how PHP handles names and content as two different concepts assignment can be seen as copying the content and assigning this new content a name. In practice, a copy-on-write strategy is employed which increases performance and decreases memory usage compared with a naive copy-on-assign strategy. In program \ref{lst:copy-on-write} after line 3 both \texttt{\$a}, \texttt{\$b}, and \texttt{\$c} point to the same array. After evaluating line 4 the array is copied, updated and \texttt{\$b} now points to the new array. Meanwhile \texttt{\$a} and \texttt{\$c} are still pointing to the same array since none of them has changed from the original array. In the example only two copies of the array are ever stored whereas a blind copy-on-assign strategy would have stored three copies of which two would never differ.

\begin{program}
\begin{lstlisting}
$a = [1,2,3];
$b = $a;
$c = $b;
$b[1] = 5;
echo $a[1] . ", " . $b[1] . ", " . $c[1];
// Result: 2, 5, 2
\end{lstlisting}
\caption{Copy-on-write strategy}
\label{lst:copy-on-write}
\end{program}

As an alternative PHP offers an explicit way to assign and pass function parameters by-reference. Using the ampersand operator multiple variables can reference the same value as shown in program \ref{lst:alias}

\begin{program}
\begin{lstlisting}
function byvalFunc($input) {
    $input["hello"] = "PHP";
}

function byrefFunc(&$input) {
    $input["hello"] = "PHP";
}

$greet = ["hello" => "world"];
byvalFunc($greet);
echo $greet["hello"]; // Result: world
byrefFunc($greet);
echo $greet["hello"]; // Result: PHP
\end{lstlisting}
\caption{Aliasing}
\label{lst:alias}
\end{program}

PHP arrays are treated as ordinary values and are thus copied like other values when assigning variables. The copy is deep in that the inner-arrays of multi-dimensional arrays will be copied as well. There is however one exception to the deep-copy of arrays namely that references inside arrays are kept even after copying. This effect can be seen in program \ref{lst:not-deep-copy}.

\begin{program}
\begin{lstlisting}
$a = [1,2,3];
$c = &$a[0];
$b = $a;
$c = 5; // Result: $a = [5,2,3]; $b = [5,2,3]; $c = 5;
$b[0] = 6; // Result: $a = [6,2,3]; $b = [6,2,3]; $c = 6;
$a[0] = 7; // Result: $a = [7,2,3]; $b = [7,2,3]; $c = 7;
$b[1] = 8; // Result: $a = [7,2,3]; $b = [7,8,3];
\end{lstlisting}
\caption{Keeping references in arrays}
\label{lst:not-deep-copy}
\end{program}